/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class IConfig {
    /* 
      ApiClient.ts
      This is the base classes for the NSwag generated ApiClient. Has overrides for transformOptions and getBaseUrl to allow me to instantiate a client and
      inject firebase authorization tokens into the request header for the back end to then verify and get my own baseUrl stored in a config file.
      A comment at the top of this file will actually break client generation and for whatever reason this will end up at the bottom of Client.ts not the top.
    */
    constructor(token: string) {
        this.JwtToken = token;
    }
    /*
      Returns a valid value for the Authorization header.
      Used to dynamically inject the current auth header.
     */
    JwtToken: string;
}

export class AuthorizedApiBase {
    private readonly config: IConfig;

    protected constructor(config: IConfig) {
        this.config = config;
    }

    protected transformOptions = (options: RequestInit): Promise<RequestInit> => {
        options.headers = {
            ...options.headers,
            Authorization: this.config.JwtToken,
        };
        return Promise.resolve(options);
    };

    protected getBaseUrl = (defaultUrl: string, baseUrl?: string) => {
        const ApiUrl = "";
        return ApiUrl !== undefined ? ApiUrl : defaultUrl;
    };
}

export class Client extends AuthorizedApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: IConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    authentication_GetOAuthTokenWithUserInfo(code: string | null, state: string | null, metadata: any | undefined): Promise<TokenUserResponse> {
        let url_ = this.baseUrl + "/auth/token/{code}/{state}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthentication_GetOAuthTokenWithUserInfo(_response);
        });
    }

    protected processAuthentication_GetOAuthTokenWithUserInfo(response: Response): Promise<TokenUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenUserResponse>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    authentication_GetLoginRedirectUrl(metadata: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/auth/login-redirect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthentication_GetLoginRedirectUrl(_response);
        });
    }

    protected processAuthentication_GetLoginRedirectUrl(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    authentication_GetUserInformationForToken(metadata: any | undefined): Promise<UserInfoResult> {
        let url_ = this.baseUrl + "/auth/user-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuthentication_GetUserInformationForToken(_response);
        });
    }

    protected processAuthentication_GetUserInformationForToken(response: Response): Promise<UserInfoResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfoResult>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    pullRequest_GetPullRequests(pullFilterOption: PullRequestFilterOption, metadata: any | undefined): Promise<UserPullRequestResult[]> {
        let url_ = this.baseUrl + "/pull-requests/{pullFilterOption}";
        if (pullFilterOption === undefined || pullFilterOption === null)
            throw new Error("The parameter 'pullFilterOption' must be defined.");
        url_ = url_.replace("{pullFilterOption}", encodeURIComponent("" + pullFilterOption));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPullRequest_GetPullRequests(_response);
        });
    }

    protected processPullRequest_GetPullRequests(response: Response): Promise<UserPullRequestResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserPullRequestResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPullRequestResult[]>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    pullRequest_GetDetailedPullRequest(repoId: number, pullNumber: number, metadata: any | undefined): Promise<DetailedPullRequest> {
        let url_ = this.baseUrl + "/pull-requests/detailed/{repoId}/{pullNumber}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (pullNumber === undefined || pullNumber === null)
            throw new Error("The parameter 'pullNumber' must be defined.");
        url_ = url_.replace("{pullNumber}", encodeURIComponent("" + pullNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPullRequest_GetDetailedPullRequest(_response);
        });
    }

    protected processPullRequest_GetDetailedPullRequest(response: Response): Promise<DetailedPullRequest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DetailedPullRequest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DetailedPullRequest>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    pullRequest_GetPullFileInformation(repoId: number, pullNumber: number, fileName: string | null, extension: string | null, metadata: any | undefined): Promise<PullFileInfo> {
        let url_ = this.baseUrl + "/pull-requests/file-info/{repoId}/{pullNumber}/{fileName}/{extension}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (pullNumber === undefined || pullNumber === null)
            throw new Error("The parameter 'pullNumber' must be defined.");
        url_ = url_.replace("{pullNumber}", encodeURIComponent("" + pullNumber));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (extension === undefined || extension === null)
            throw new Error("The parameter 'extension' must be defined.");
        url_ = url_.replace("{extension}", encodeURIComponent("" + extension));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPullRequest_GetPullFileInformation(_response);
        });
    }

    protected processPullRequest_GetPullFileInformation(response: Response): Promise<PullFileInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PullFileInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PullFileInfo>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    pullRequest_GetPullIssuesAndDiscussion(repoId: number, pullNumber: number, metadata: any | undefined): Promise<PullDiscussionResult> {
        let url_ = this.baseUrl + "/pull-requests/discussion-issues/{repoId}/{pullNumber}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (pullNumber === undefined || pullNumber === null)
            throw new Error("The parameter 'pullNumber' must be defined.");
        url_ = url_.replace("{pullNumber}", encodeURIComponent("" + pullNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPullRequest_GetPullIssuesAndDiscussion(_response);
        });
    }

    protected processPullRequest_GetPullIssuesAndDiscussion(response: Response): Promise<PullDiscussionResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PullDiscussionResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PullDiscussionResult>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    pullRequest_GetPullRequestSummary(repoId: number, pullNumber: number, metadata: any | undefined): Promise<PullSummaryResponse> {
        let url_ = this.baseUrl + "/pull-requests/summary/{repoId}/{pullNumber}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (pullNumber === undefined || pullNumber === null)
            throw new Error("The parameter 'pullNumber' must be defined.");
        url_ = url_.replace("{pullNumber}", encodeURIComponent("" + pullNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPullRequest_GetPullRequestSummary(_response);
        });
    }

    protected processPullRequest_GetPullRequestSummary(response: Response): Promise<PullSummaryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PullSummaryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PullSummaryResponse>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    repository_Repositories(filterOption: RepoFilterOptions, metadata: any | undefined): Promise<UserRepositoryResult[]> {
        let url_ = this.baseUrl + "/repositories/{filterOption}";
        if (filterOption === undefined || filterOption === null)
            throw new Error("The parameter 'filterOption' must be defined.");
        url_ = url_.replace("{filterOption}", encodeURIComponent("" + filterOption));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_Repositories(_response);
        });
    }

    protected processRepository_Repositories(response: Response): Promise<UserRepositoryResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRepositoryResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRepositoryResult[]>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetDetailedRepository(repoId: number, metadata: any | undefined): Promise<DetailedRepository> {
        let url_ = this.baseUrl + "/repositories/detailed/{repoId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetDetailedRepository(_response);
        });
    }

    protected processRepository_GetDetailedRepository(response: Response): Promise<DetailedRepository> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DetailedRepository.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DetailedRepository>(<any>null);
    }

    /**
     * @param connectionId SignalR Client Connection ID
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetCyclomaticComplexities(connectionId: string, metadata: any | undefined, request: CyclomaticComplexityRequest): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/repositories/complexities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "ConnectionId": connectionId !== undefined && connectionId !== null ? "" + connectionId : "",
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetCyclomaticComplexities(_response);
        });
    }

    protected processRepository_GetCyclomaticComplexities(response: Response): Promise<{ [key: string]: number; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(<any>null);
    }

    /**
     * @param connectionId SignalR Client Connection ID
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetCodeOwnersForRepo(repoId: number, connectionId: string, metadata: any | undefined): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/repositories/code-owners/{repoId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ConnectionId": connectionId !== undefined && connectionId !== null ? "" + connectionId : "",
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetCodeOwnersForRepo(_response);
        });
    }

    protected processRepository_GetCodeOwnersForRepo(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetFileInformation(repoId: number, fileName: string | null, extension: string | null, metadata: any | undefined): Promise<GitHubCommit[]> {
        let url_ = this.baseUrl + "/repositories/file-info/{repoId}/{fileName}/{extension}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (extension === undefined || extension === null)
            throw new Error("The parameter 'extension' must be defined.");
        url_ = url_.replace("{extension}", encodeURIComponent("" + extension));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetFileInformation(_response);
        });
    }

    protected processRepository_GetFileInformation(response: Response): Promise<GitHubCommit[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GitHubCommit.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GitHubCommit[]>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetRepoIssues(repoId: number, metadata: any | undefined): Promise<RepoIssuesResponse> {
        let url_ = this.baseUrl + "/repositories/issues/{repoId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetRepoIssues(_response);
        });
    }

    protected processRepository_GetRepoIssues(response: Response): Promise<RepoIssuesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoIssuesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoIssuesResponse>(<any>null);
    }

    /**
     * @param connectionId SignalR Client Connection ID
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetRepoContributionVolumes(repoId: number, connectionId: string, metadata: any | undefined): Promise<RepoContributionResponse> {
        let url_ = this.baseUrl + "/repositories/contribution-volume/{repoId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ConnectionId": connectionId !== undefined && connectionId !== null ? "" + connectionId : "",
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetRepoContributionVolumes(_response);
        });
    }

    protected processRepository_GetRepoContributionVolumes(response: Response): Promise<RepoContributionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoContributionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoContributionResponse>(<any>null);
    }

    /**
     * @param connectionId SignalR Client Connection ID
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetRepoSummary(repoId: number, connectionId: string, metadata: any | undefined): Promise<RepoSummaryResponse> {
        let url_ = this.baseUrl + "/repositories/summary/{repoId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ConnectionId": connectionId !== undefined && connectionId !== null ? "" + connectionId : "",
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetRepoSummary(_response);
        });
    }

    protected processRepository_GetRepoSummary(response: Response): Promise<RepoSummaryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepoSummaryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepoSummaryResponse>(<any>null);
    }

    /**
     * @param connectionId SignalR Client Connection ID
     * @param metadata (optional) Client Metadata JSON
     */
    repository_GetGendarmeReportHtml(repoId: number, connectionId: string, metadata: any | undefined): Promise<string> {
        let url_ = this.baseUrl + "/repositories/gendarme-report/{repoId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "ConnectionId": connectionId !== undefined && connectionId !== null ? "" + connectionId : "",
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRepository_GetGendarmeReportHtml(_response);
        });
    }

    protected processRepository_GetGendarmeReportHtml(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    statistics_GetUserStatistics(page: number, pageSize: number, metadata: any | undefined): Promise<UserActivity> {
        let url_ = this.baseUrl + "/statistics/user/{page}/{pageSize}";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined.");
        url_ = url_.replace("{page}", encodeURIComponent("" + page));
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined.");
        url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStatistics_GetUserStatistics(_response);
        });
    }

    protected processStatistics_GetUserStatistics(response: Response): Promise<UserActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserActivity>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    statistics_GetLandingPageStatistics(metadata: any | undefined): Promise<UserLandingPageStatistics> {
        let url_ = this.baseUrl + "/statistics/landing";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processStatistics_GetLandingPageStatistics(_response);
        });
    }

    protected processStatistics_GetLandingPageStatistics(response: Response): Promise<UserLandingPageStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLandingPageStatistics.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLandingPageStatistics>(<any>null);
    }

    /**
     * @param metadata (optional) Client Metadata JSON
     */
    utilities_GetDetailedRepository(metadata: any | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/utilities/truncate-request-audits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Metadata": metadata !== undefined && metadata !== null ? "" + metadata : "",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUtilities_GetDetailedRepository(_response);
        });
    }

    protected processUtilities_GetDetailedRepository(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundResponse.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = UnauthorizedResponse.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationResponse.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export abstract class BaseResponse implements IBaseResponse {
    message?: string | undefined;
    title?: string | undefined;

    constructor(data?: IBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): BaseResponse {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseResponse' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["title"] = this.title;
        return data; 
    }
}

export interface IBaseResponse {
    message?: string | undefined;
    title?: string | undefined;
}

export class NotFoundResponse extends BaseResponse implements INotFoundResponse {
    badProperties?: { [key: string]: string; } | undefined;

    constructor(data?: INotFoundResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["badProperties"]) {
                this.badProperties = {} as any;
                for (let key in _data["badProperties"]) {
                    if (_data["badProperties"].hasOwnProperty(key))
                        (<any>this.badProperties)![key] = _data["badProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotFoundResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotFoundResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.badProperties) {
            data["badProperties"] = {};
            for (let key in this.badProperties) {
                if (this.badProperties.hasOwnProperty(key))
                    (<any>data["badProperties"])[key] = this.badProperties[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface INotFoundResponse extends IBaseResponse {
    badProperties?: { [key: string]: string; } | undefined;
}

export class UnauthorizedResponse extends BaseResponse implements IUnauthorizedResponse {

    constructor(data?: IUnauthorizedResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UnauthorizedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnauthorizedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUnauthorizedResponse extends IBaseResponse {
}

export class ValidationResponse extends BaseResponse implements IValidationResponse {
    validationErrors?: { [key: string]: string; } | undefined;

    constructor(data?: IValidationResponse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["validationErrors"]) {
                this.validationErrors = {} as any;
                for (let key in _data["validationErrors"]) {
                    if (_data["validationErrors"].hasOwnProperty(key))
                        (<any>this.validationErrors)![key] = _data["validationErrors"][key];
                }
            }
        }
    }

    static fromJS(data: any): ValidationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.validationErrors) {
            data["validationErrors"] = {};
            for (let key in this.validationErrors) {
                if (this.validationErrors.hasOwnProperty(key))
                    (<any>data["validationErrors"])[key] = this.validationErrors[key];
            }
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IValidationResponse extends IBaseResponse {
    validationErrors?: { [key: string]: string; } | undefined;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
    /** Gets the IDictionary`2 for extension members.

Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
other members of a problem type. */
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data; 
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
    /** Gets the IDictionary`2 for extension members.

Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
other members of a problem type. */
    extensions?: { [key: string]: any; } | undefined;
}

export class TokenUserResponse implements ITokenUserResponse {
    accessToken?: string | undefined;
    user?: User | undefined;

    constructor(data?: ITokenUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITokenUserResponse {
    accessToken?: string | undefined;
    user?: User | undefined;
}

/** Base class for a GitHub account, most often either a User or Organization. */
export abstract class Account implements IAccount {
    /** URL of the account's avatar. */
    avatarUrl?: string | undefined;
    /** The account's bio. */
    bio?: string | undefined;
    /** URL of the account's blog. */
    blog?: string | undefined;
    /** Number of collaborators the account has. */
    collaborators?: number | undefined;
    /** Company the account works for. */
    company?: string | undefined;
    /** Date the account was created. */
    createdAt?: Date;
    /** Amount of disk space the account is using. */
    diskUsage?: number | undefined;
    /** The account's email. */
    email?: string | undefined;
    /** Number of followers the account has. */
    followers?: number;
    /** Number of other users the account is following. */
    following?: number;
    /** Indicates whether the account is currently hireable. */
    hireable?: boolean | undefined;
    /** The HTML URL for the account on github.com (or GitHub Enterprise). */
    htmlUrl?: string | undefined;
    /** The account's system-wide unique Id. */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The account's geographic location. */
    location?: string | undefined;
    /** The account's login. */
    login?: string | undefined;
    /** The account's full name. */
    name?: string | undefined;
    /** The type of account associated with this entity */
    type?: AccountType | undefined;
    /** Number of private repos owned by the account. */
    ownedPrivateRepos?: number;
    /** Plan the account pays for. */
    plan?: Plan | undefined;
    /** Number of private gists the account has created. */
    privateGists?: number | undefined;
    /** Number of public gists the account has created. */
    publicGists?: number;
    /** Number of public repos the account owns. */
    publicRepos?: number;
    /** Total number of private repos the account owns. */
    totalPrivateRepos?: number;
    /** The account's API URL. */
    url?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.avatarUrl = _data["avatarUrl"];
            this.bio = _data["bio"];
            this.blog = _data["blog"];
            this.collaborators = _data["collaborators"];
            this.company = _data["company"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.diskUsage = _data["diskUsage"];
            this.email = _data["email"];
            this.followers = _data["followers"];
            this.following = _data["following"];
            this.hireable = _data["hireable"];
            this.htmlUrl = _data["htmlUrl"];
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.location = _data["location"];
            this.login = _data["login"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.ownedPrivateRepos = _data["ownedPrivateRepos"];
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            this.privateGists = _data["privateGists"];
            this.publicGists = _data["publicGists"];
            this.publicRepos = _data["publicRepos"];
            this.totalPrivateRepos = _data["totalPrivateRepos"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Account' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarUrl"] = this.avatarUrl;
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["collaborators"] = this.collaborators;
        data["company"] = this.company;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["diskUsage"] = this.diskUsage;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["hireable"] = this.hireable;
        data["htmlUrl"] = this.htmlUrl;
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["type"] = this.type;
        data["ownedPrivateRepos"] = this.ownedPrivateRepos;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["privateGists"] = this.privateGists;
        data["publicGists"] = this.publicGists;
        data["publicRepos"] = this.publicRepos;
        data["totalPrivateRepos"] = this.totalPrivateRepos;
        data["url"] = this.url;
        return data; 
    }
}

/** Base class for a GitHub account, most often either a User or Organization. */
export interface IAccount {
    /** URL of the account's avatar. */
    avatarUrl?: string | undefined;
    /** The account's bio. */
    bio?: string | undefined;
    /** URL of the account's blog. */
    blog?: string | undefined;
    /** Number of collaborators the account has. */
    collaborators?: number | undefined;
    /** Company the account works for. */
    company?: string | undefined;
    /** Date the account was created. */
    createdAt?: Date;
    /** Amount of disk space the account is using. */
    diskUsage?: number | undefined;
    /** The account's email. */
    email?: string | undefined;
    /** Number of followers the account has. */
    followers?: number;
    /** Number of other users the account is following. */
    following?: number;
    /** Indicates whether the account is currently hireable. */
    hireable?: boolean | undefined;
    /** The HTML URL for the account on github.com (or GitHub Enterprise). */
    htmlUrl?: string | undefined;
    /** The account's system-wide unique Id. */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The account's geographic location. */
    location?: string | undefined;
    /** The account's login. */
    login?: string | undefined;
    /** The account's full name. */
    name?: string | undefined;
    /** The type of account associated with this entity */
    type?: AccountType | undefined;
    /** Number of private repos owned by the account. */
    ownedPrivateRepos?: number;
    /** Plan the account pays for. */
    plan?: Plan | undefined;
    /** Number of private gists the account has created. */
    privateGists?: number | undefined;
    /** Number of public gists the account has created. */
    publicGists?: number;
    /** Number of public repos the account owns. */
    publicRepos?: number;
    /** Total number of private repos the account owns. */
    totalPrivateRepos?: number;
    /** The account's API URL. */
    url?: string | undefined;
}

/** Represents a user on GitHub. */
export class User extends Account implements IUser {
    permissions?: RepositoryPermissions | undefined;
    /** Whether or not the user is an administrator of the site */
    siteAdmin?: boolean;
    /** When the user was suspended, if at all (GitHub Enterprise) */
    suspendedAt?: Date | undefined;
    /** Whether or not the user is currently suspended */
    suspended?: boolean;
    /** LDAP Binding (GitHub Enterprise only) */
    ldapDistinguishedName?: string | undefined;
    /** Date the user account was updated. */
    updatedAt?: Date;

    constructor(data?: IUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.permissions = _data["permissions"] ? RepositoryPermissions.fromJS(_data["permissions"]) : <any>undefined;
            this.siteAdmin = _data["siteAdmin"];
            this.suspendedAt = _data["suspendedAt"] ? new Date(_data["suspendedAt"].toString()) : <any>undefined;
            this.suspended = _data["suspended"];
            this.ldapDistinguishedName = _data["ldapDistinguishedName"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissions"] = this.permissions ? this.permissions.toJSON() : <any>undefined;
        data["siteAdmin"] = this.siteAdmin;
        data["suspendedAt"] = this.suspendedAt ? this.suspendedAt.toISOString() : <any>undefined;
        data["suspended"] = this.suspended;
        data["ldapDistinguishedName"] = this.ldapDistinguishedName;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

/** Represents a user on GitHub. */
export interface IUser extends IAccount {
    permissions?: RepositoryPermissions | undefined;
    /** Whether or not the user is an administrator of the site */
    siteAdmin?: boolean;
    /** When the user was suspended, if at all (GitHub Enterprise) */
    suspendedAt?: Date | undefined;
    /** Whether or not the user is currently suspended */
    suspended?: boolean;
    /** LDAP Binding (GitHub Enterprise only) */
    ldapDistinguishedName?: string | undefined;
    /** Date the user account was updated. */
    updatedAt?: Date;
}

export class RepositoryPermissions implements IRepositoryPermissions {
    /** Whether the current user has administrative permissions */
    admin?: boolean;
    /** Whether the current user has push permissions */
    push?: boolean;
    /** Whether the current user has pull permissions */
    pull?: boolean;

    constructor(data?: IRepositoryPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admin = _data["admin"];
            this.push = _data["push"];
            this.pull = _data["pull"];
        }
    }

    static fromJS(data: any): RepositoryPermissions {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryPermissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin"] = this.admin;
        data["push"] = this.push;
        data["pull"] = this.pull;
        return data; 
    }
}

export interface IRepositoryPermissions {
    /** Whether the current user has administrative permissions */
    admin?: boolean;
    /** Whether the current user has push permissions */
    push?: boolean;
    /** Whether the current user has pull permissions */
    pull?: boolean;
}

export enum AccountType {
    User = 0,
    Organization = 1,
    Bot = 2,
}

/** A plan (either paid or free) for a particular user */
export class Plan implements IPlan {
    /** The number of collaborators allowed with this plan. */
    collaborators?: number;
    /** The name of the plan. */
    name?: string | undefined;
    /** The number of private repositories allowed with this plan. */
    privateRepos?: number;
    /** The amount of disk space allowed with this plan. */
    space?: number;
    /** The billing email for the organization. Only has a value in response to editing an organization. */
    billingEmail?: string | undefined;

    constructor(data?: IPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collaborators = _data["collaborators"];
            this.name = _data["name"];
            this.privateRepos = _data["privateRepos"];
            this.space = _data["space"];
            this.billingEmail = _data["billingEmail"];
        }
    }

    static fromJS(data: any): Plan {
        data = typeof data === 'object' ? data : {};
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collaborators"] = this.collaborators;
        data["name"] = this.name;
        data["privateRepos"] = this.privateRepos;
        data["space"] = this.space;
        data["billingEmail"] = this.billingEmail;
        return data; 
    }
}

/** A plan (either paid or free) for a particular user */
export interface IPlan {
    /** The number of collaborators allowed with this plan. */
    collaborators?: number;
    /** The name of the plan. */
    name?: string | undefined;
    /** The number of private repositories allowed with this plan. */
    privateRepos?: number;
    /** The amount of disk space allowed with this plan. */
    space?: number;
    /** The billing email for the organization. Only has a value in response to editing an organization. */
    billingEmail?: string | undefined;
}

export class UserInfoResult implements IUserInfoResult {
    user?: User | undefined;
    loginRedirectUrl?: string | undefined;

    constructor(data?: IUserInfoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.loginRedirectUrl = _data["loginRedirectUrl"];
        }
    }

    static fromJS(data: any): UserInfoResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["loginRedirectUrl"] = this.loginRedirectUrl;
        return data; 
    }
}

export interface IUserInfoResult {
    user?: User | undefined;
    loginRedirectUrl?: string | undefined;
}

export class UserPullRequestResult implements IUserPullRequestResult {
    repositoryId?: number;
    repositoryName?: string | undefined;
    pullRequestNumber?: number;
    closedAt?: Date | undefined;
    updatedAt?: Date | undefined;
    additions?: number;
    deletions?: number;
    headBranchName?: string | undefined;
    changedFiles?: number;
    closed?: boolean;
    state?: PullRequestState;
    collaborators?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    descriptionMarkdown?: string | undefined;

    constructor(data?: IUserPullRequestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repositoryId = _data["repositoryId"];
            this.repositoryName = _data["repositoryName"];
            this.pullRequestNumber = _data["pullRequestNumber"];
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.additions = _data["additions"];
            this.deletions = _data["deletions"];
            this.headBranchName = _data["headBranchName"];
            this.changedFiles = _data["changedFiles"];
            this.closed = _data["closed"];
            this.state = _data["state"];
            if (Array.isArray(_data["collaborators"])) {
                this.collaborators = [] as any;
                for (let item of _data["collaborators"])
                    this.collaborators!.push(item);
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.descriptionMarkdown = _data["descriptionMarkdown"];
        }
    }

    static fromJS(data: any): UserPullRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserPullRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repositoryId"] = this.repositoryId;
        data["repositoryName"] = this.repositoryName;
        data["pullRequestNumber"] = this.pullRequestNumber;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["headBranchName"] = this.headBranchName;
        data["changedFiles"] = this.changedFiles;
        data["closed"] = this.closed;
        data["state"] = this.state;
        if (Array.isArray(this.collaborators)) {
            data["collaborators"] = [];
            for (let item of this.collaborators)
                data["collaborators"].push(item);
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["descriptionMarkdown"] = this.descriptionMarkdown;
        return data; 
    }
}

export interface IUserPullRequestResult {
    repositoryId?: number;
    repositoryName?: string | undefined;
    pullRequestNumber?: number;
    closedAt?: Date | undefined;
    updatedAt?: Date | undefined;
    additions?: number;
    deletions?: number;
    headBranchName?: string | undefined;
    changedFiles?: number;
    closed?: boolean;
    state?: PullRequestState;
    collaborators?: string[] | undefined;
    title?: string | undefined;
    description?: string | undefined;
    descriptionMarkdown?: string | undefined;
}

export enum PullRequestState {
    Open = "OPEN",
    Closed = "CLOSED",
    Merged = "MERGED",
}

export enum PullRequestFilterOption {
    All = 1,
    Closed = 2,
    Open = 3,
    Merged = 4,
}

export class DetailedPullRequest implements IDetailedPullRequest {
    pullRequest?: UserPullRequestResult | undefined;
    commits?: GitHubCommit[] | undefined;
    modifiedFilePaths?: string[] | undefined;
    isDotNetProject?: boolean;

    constructor(data?: IDetailedPullRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pullRequest = _data["pullRequest"] ? UserPullRequestResult.fromJS(_data["pullRequest"]) : <any>undefined;
            if (Array.isArray(_data["commits"])) {
                this.commits = [] as any;
                for (let item of _data["commits"])
                    this.commits!.push(GitHubCommit.fromJS(item));
            }
            if (Array.isArray(_data["modifiedFilePaths"])) {
                this.modifiedFilePaths = [] as any;
                for (let item of _data["modifiedFilePaths"])
                    this.modifiedFilePaths!.push(item);
            }
            this.isDotNetProject = _data["isDotNetProject"];
        }
    }

    static fromJS(data: any): DetailedPullRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DetailedPullRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pullRequest"] = this.pullRequest ? this.pullRequest.toJSON() : <any>undefined;
        if (Array.isArray(this.commits)) {
            data["commits"] = [];
            for (let item of this.commits)
                data["commits"].push(item.toJSON());
        }
        if (Array.isArray(this.modifiedFilePaths)) {
            data["modifiedFilePaths"] = [];
            for (let item of this.modifiedFilePaths)
                data["modifiedFilePaths"].push(item);
        }
        data["isDotNetProject"] = this.isDotNetProject;
        return data; 
    }
}

export interface IDetailedPullRequest {
    pullRequest?: UserPullRequestResult | undefined;
    commits?: GitHubCommit[] | undefined;
    modifiedFilePaths?: string[] | undefined;
    isDotNetProject?: boolean;
}

export class GitReference implements IGitReference {
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL associated with this reference. */
    url?: string | undefined;
    /** The reference label. */
    label?: string | undefined;
    /** The reference identifier. */
    ref?: string | undefined;
    /** The sha value of the reference. */
    sha?: string | undefined;
    /** The user associated with this reference. */
    user?: User | undefined;
    /** The repository associated with this reference. */
    repository?: Repository | undefined;

    constructor(data?: IGitReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodeId = _data["nodeId"];
            this.url = _data["url"];
            this.label = _data["label"];
            this.ref = _data["ref"];
            this.sha = _data["sha"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GitReference {
        data = typeof data === 'object' ? data : {};
        let result = new GitReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodeId"] = this.nodeId;
        data["url"] = this.url;
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGitReference {
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL associated with this reference. */
    url?: string | undefined;
    /** The reference label. */
    label?: string | undefined;
    /** The reference identifier. */
    ref?: string | undefined;
    /** The sha value of the reference. */
    sha?: string | undefined;
    /** The user associated with this reference. */
    user?: User | undefined;
    /** The repository associated with this reference. */
    repository?: Repository | undefined;
}

/** An enhanced git commit containing links to additional resources */
export class GitHubCommit extends GitReference implements IGitHubCommit {
    /** Gets the GitHub account information for the commit author. It attempts to match the email
address used in the commit with the email addresses registered with the GitHub account.
If no account corresponds to the commit email, then this property is null. */
    author?: Author | undefined;
    commentsUrl?: string | undefined;
    commit?: Commit | undefined;
    /** Gets the GitHub account information for the commit committer. It attempts to match the email
address used in the commit with the email addresses registered with the GitHub account.
If no account corresponds to the commit email, then this property is null. */
    committer?: Author | undefined;
    htmlUrl?: string | undefined;
    stats?: GitHubCommitStats | undefined;
    parents?: GitReference[] | undefined;
    files?: GitHubCommitFile[] | undefined;

    constructor(data?: IGitHubCommit) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.author = _data["author"] ? Author.fromJS(_data["author"]) : <any>undefined;
            this.commentsUrl = _data["commentsUrl"];
            this.commit = _data["commit"] ? Commit.fromJS(_data["commit"]) : <any>undefined;
            this.committer = _data["committer"] ? Author.fromJS(_data["committer"]) : <any>undefined;
            this.htmlUrl = _data["htmlUrl"];
            this.stats = _data["stats"] ? GitHubCommitStats.fromJS(_data["stats"]) : <any>undefined;
            if (Array.isArray(_data["parents"])) {
                this.parents = [] as any;
                for (let item of _data["parents"])
                    this.parents!.push(GitReference.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(GitHubCommitFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GitHubCommit {
        data = typeof data === 'object' ? data : {};
        let result = new GitHubCommit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commentsUrl"] = this.commentsUrl;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["htmlUrl"] = this.htmlUrl;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        if (Array.isArray(this.parents)) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

/** An enhanced git commit containing links to additional resources */
export interface IGitHubCommit extends IGitReference {
    /** Gets the GitHub account information for the commit author. It attempts to match the email
address used in the commit with the email addresses registered with the GitHub account.
If no account corresponds to the commit email, then this property is null. */
    author?: Author | undefined;
    commentsUrl?: string | undefined;
    commit?: Commit | undefined;
    /** Gets the GitHub account information for the commit committer. It attempts to match the email
address used in the commit with the email addresses registered with the GitHub account.
If no account corresponds to the commit email, then this property is null. */
    committer?: Author | undefined;
    htmlUrl?: string | undefined;
    stats?: GitHubCommitStats | undefined;
    parents?: GitReference[] | undefined;
    files?: GitHubCommitFile[] | undefined;
}

export class Author implements IAuthor {
    login?: string | undefined;
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    avatarUrl?: string | undefined;
    url?: string | undefined;
    htmlUrl?: string | undefined;
    followersUrl?: string | undefined;
    followingUrl?: string | undefined;
    gistsUrl?: string | undefined;
    starredUrl?: string | undefined;
    subscriptionsUrl?: string | undefined;
    organizationsUrl?: string | undefined;
    reposUrl?: string | undefined;
    eventsUrl?: string | undefined;
    receivedEventsUrl?: string | undefined;
    type?: string | undefined;
    siteAdmin?: boolean;

    constructor(data?: IAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.avatarUrl = _data["avatarUrl"];
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.followersUrl = _data["followersUrl"];
            this.followingUrl = _data["followingUrl"];
            this.gistsUrl = _data["gistsUrl"];
            this.starredUrl = _data["starredUrl"];
            this.subscriptionsUrl = _data["subscriptionsUrl"];
            this.organizationsUrl = _data["organizationsUrl"];
            this.reposUrl = _data["reposUrl"];
            this.eventsUrl = _data["eventsUrl"];
            this.receivedEventsUrl = _data["receivedEventsUrl"];
            this.type = _data["type"];
            this.siteAdmin = _data["siteAdmin"];
        }
    }

    static fromJS(data: any): Author {
        data = typeof data === 'object' ? data : {};
        let result = new Author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["avatarUrl"] = this.avatarUrl;
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["followersUrl"] = this.followersUrl;
        data["followingUrl"] = this.followingUrl;
        data["gistsUrl"] = this.gistsUrl;
        data["starredUrl"] = this.starredUrl;
        data["subscriptionsUrl"] = this.subscriptionsUrl;
        data["organizationsUrl"] = this.organizationsUrl;
        data["reposUrl"] = this.reposUrl;
        data["eventsUrl"] = this.eventsUrl;
        data["receivedEventsUrl"] = this.receivedEventsUrl;
        data["type"] = this.type;
        data["siteAdmin"] = this.siteAdmin;
        return data; 
    }
}

export interface IAuthor {
    login?: string | undefined;
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    avatarUrl?: string | undefined;
    url?: string | undefined;
    htmlUrl?: string | undefined;
    followersUrl?: string | undefined;
    followingUrl?: string | undefined;
    gistsUrl?: string | undefined;
    starredUrl?: string | undefined;
    subscriptionsUrl?: string | undefined;
    organizationsUrl?: string | undefined;
    reposUrl?: string | undefined;
    eventsUrl?: string | undefined;
    receivedEventsUrl?: string | undefined;
    type?: string | undefined;
    siteAdmin?: boolean;
}

export class Commit extends GitReference implements ICommit {
    message?: string | undefined;
    author?: Committer | undefined;
    committer?: Committer | undefined;
    tree?: GitReference | undefined;
    parents?: GitReference[] | undefined;
    commentCount?: number;
    verification?: Verification | undefined;

    constructor(data?: ICommit) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.message = _data["message"];
            this.author = _data["author"] ? Committer.fromJS(_data["author"]) : <any>undefined;
            this.committer = _data["committer"] ? Committer.fromJS(_data["committer"]) : <any>undefined;
            this.tree = _data["tree"] ? GitReference.fromJS(_data["tree"]) : <any>undefined;
            if (Array.isArray(_data["parents"])) {
                this.parents = [] as any;
                for (let item of _data["parents"])
                    this.parents!.push(GitReference.fromJS(item));
            }
            this.commentCount = _data["commentCount"];
            this.verification = _data["verification"] ? Verification.fromJS(_data["verification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Commit {
        data = typeof data === 'object' ? data : {};
        let result = new Commit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        if (Array.isArray(this.parents)) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["commentCount"] = this.commentCount;
        data["verification"] = this.verification ? this.verification.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ICommit extends IGitReference {
    message?: string | undefined;
    author?: Committer | undefined;
    committer?: Committer | undefined;
    tree?: GitReference | undefined;
    parents?: GitReference[] | undefined;
    commentCount?: number;
    verification?: Verification | undefined;
}

/** Represents the author or committer to a Git commit. This is the information stored in Git and should not be confused with GitHub account information. */
export class Committer implements ICommitter {
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Gets the name of the author or committer. */
    name?: string | undefined;
    /** Gets the email of the author or committer. */
    email?: string | undefined;
    /** Gets the date of the author or contributor's contributions. */
    date?: Date;

    constructor(data?: ICommitter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodeId = _data["nodeId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Committer {
        data = typeof data === 'object' ? data : {};
        let result = new Committer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodeId"] = this.nodeId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }
}

/** Represents the author or committer to a Git commit. This is the information stored in Git and should not be confused with GitHub account information. */
export interface ICommitter {
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Gets the name of the author or committer. */
    name?: string | undefined;
    /** Gets the email of the author or committer. */
    email?: string | undefined;
    /** Gets the date of the author or contributor's contributions. */
    date?: Date;
}

export class Repository implements IRepository {
    url?: string | undefined;
    htmlUrl?: string | undefined;
    cloneUrl?: string | undefined;
    gitUrl?: string | undefined;
    sshUrl?: string | undefined;
    svnUrl?: string | undefined;
    mirrorUrl?: string | undefined;
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    owner?: User | undefined;
    name?: string | undefined;
    fullName?: string | undefined;
    isTemplate?: boolean;
    description?: string | undefined;
    homepage?: string | undefined;
    language?: string | undefined;
    private?: boolean;
    fork?: boolean;
    forksCount?: number;
    stargazersCount?: number;
    watchersCount?: number;
    defaultBranch?: string | undefined;
    openIssuesCount?: number;
    pushedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    permissions?: RepositoryPermissions | undefined;
    parent?: Repository | undefined;
    source?: Repository | undefined;
    license?: LicenseMetadata | undefined;
    hasIssues?: boolean;
    hasWiki?: boolean;
    hasDownloads?: boolean;
    allowRebaseMerge?: boolean | undefined;
    allowSquashMerge?: boolean | undefined;
    allowMergeCommit?: boolean | undefined;
    hasPages?: boolean;
    subscribersCount?: number;
    size?: number;
    archived?: boolean;
    deleteBranchOnMerge?: boolean | undefined;
    visibility?: RepositoryVisibility | undefined;

    constructor(data?: IRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.cloneUrl = _data["cloneUrl"];
            this.gitUrl = _data["gitUrl"];
            this.sshUrl = _data["sshUrl"];
            this.svnUrl = _data["svnUrl"];
            this.mirrorUrl = _data["mirrorUrl"];
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.owner = _data["owner"] ? User.fromJS(_data["owner"]) : <any>undefined;
            this.name = _data["name"];
            this.fullName = _data["fullName"];
            this.isTemplate = _data["isTemplate"];
            this.description = _data["description"];
            this.homepage = _data["homepage"];
            this.language = _data["language"];
            this.private = _data["private"];
            this.fork = _data["fork"];
            this.forksCount = _data["forksCount"];
            this.stargazersCount = _data["stargazersCount"];
            this.watchersCount = _data["watchersCount"];
            this.defaultBranch = _data["defaultBranch"];
            this.openIssuesCount = _data["openIssuesCount"];
            this.pushedAt = _data["pushedAt"] ? new Date(_data["pushedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.permissions = _data["permissions"] ? RepositoryPermissions.fromJS(_data["permissions"]) : <any>undefined;
            this.parent = _data["parent"] ? Repository.fromJS(_data["parent"]) : <any>undefined;
            this.source = _data["source"] ? Repository.fromJS(_data["source"]) : <any>undefined;
            this.license = _data["license"] ? LicenseMetadata.fromJS(_data["license"]) : <any>undefined;
            this.hasIssues = _data["hasIssues"];
            this.hasWiki = _data["hasWiki"];
            this.hasDownloads = _data["hasDownloads"];
            this.allowRebaseMerge = _data["allowRebaseMerge"];
            this.allowSquashMerge = _data["allowSquashMerge"];
            this.allowMergeCommit = _data["allowMergeCommit"];
            this.hasPages = _data["hasPages"];
            this.subscribersCount = _data["subscribersCount"];
            this.size = _data["size"];
            this.archived = _data["archived"];
            this.deleteBranchOnMerge = _data["deleteBranchOnMerge"];
            this.visibility = _data["visibility"];
        }
    }

    static fromJS(data: any): Repository {
        data = typeof data === 'object' ? data : {};
        let result = new Repository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["cloneUrl"] = this.cloneUrl;
        data["gitUrl"] = this.gitUrl;
        data["sshUrl"] = this.sshUrl;
        data["svnUrl"] = this.svnUrl;
        data["mirrorUrl"] = this.mirrorUrl;
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["isTemplate"] = this.isTemplate;
        data["description"] = this.description;
        data["homepage"] = this.homepage;
        data["language"] = this.language;
        data["private"] = this.private;
        data["fork"] = this.fork;
        data["forksCount"] = this.forksCount;
        data["stargazersCount"] = this.stargazersCount;
        data["watchersCount"] = this.watchersCount;
        data["defaultBranch"] = this.defaultBranch;
        data["openIssuesCount"] = this.openIssuesCount;
        data["pushedAt"] = this.pushedAt ? this.pushedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["permissions"] = this.permissions ? this.permissions.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["license"] = this.license ? this.license.toJSON() : <any>undefined;
        data["hasIssues"] = this.hasIssues;
        data["hasWiki"] = this.hasWiki;
        data["hasDownloads"] = this.hasDownloads;
        data["allowRebaseMerge"] = this.allowRebaseMerge;
        data["allowSquashMerge"] = this.allowSquashMerge;
        data["allowMergeCommit"] = this.allowMergeCommit;
        data["hasPages"] = this.hasPages;
        data["subscribersCount"] = this.subscribersCount;
        data["size"] = this.size;
        data["archived"] = this.archived;
        data["deleteBranchOnMerge"] = this.deleteBranchOnMerge;
        data["visibility"] = this.visibility;
        return data; 
    }
}

export interface IRepository {
    url?: string | undefined;
    htmlUrl?: string | undefined;
    cloneUrl?: string | undefined;
    gitUrl?: string | undefined;
    sshUrl?: string | undefined;
    svnUrl?: string | undefined;
    mirrorUrl?: string | undefined;
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    owner?: User | undefined;
    name?: string | undefined;
    fullName?: string | undefined;
    isTemplate?: boolean;
    description?: string | undefined;
    homepage?: string | undefined;
    language?: string | undefined;
    private?: boolean;
    fork?: boolean;
    forksCount?: number;
    stargazersCount?: number;
    watchersCount?: number;
    defaultBranch?: string | undefined;
    openIssuesCount?: number;
    pushedAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    permissions?: RepositoryPermissions | undefined;
    parent?: Repository | undefined;
    source?: Repository | undefined;
    license?: LicenseMetadata | undefined;
    hasIssues?: boolean;
    hasWiki?: boolean;
    hasDownloads?: boolean;
    allowRebaseMerge?: boolean | undefined;
    allowSquashMerge?: boolean | undefined;
    allowMergeCommit?: boolean | undefined;
    hasPages?: boolean;
    subscribersCount?: number;
    size?: number;
    archived?: boolean;
    deleteBranchOnMerge?: boolean | undefined;
    visibility?: RepositoryVisibility | undefined;
}

export class LicenseMetadata implements ILicenseMetadata {
    /** The  */
    key?: string | undefined;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Friendly name of the license. */
    name?: string | undefined;
    /** SPDX license identifier. */
    spdxId?: string | undefined;
    /** URL to retrieve details about a license. */
    url?: string | undefined;
    /** Whether the license is one of the licenses featured on https://choosealicense.com */
    featured?: boolean;

    constructor(data?: ILicenseMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.nodeId = _data["nodeId"];
            this.name = _data["name"];
            this.spdxId = _data["spdxId"];
            this.url = _data["url"];
            this.featured = _data["featured"];
        }
    }

    static fromJS(data: any): LicenseMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["nodeId"] = this.nodeId;
        data["name"] = this.name;
        data["spdxId"] = this.spdxId;
        data["url"] = this.url;
        data["featured"] = this.featured;
        return data; 
    }
}

export interface ILicenseMetadata {
    /** The  */
    key?: string | undefined;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Friendly name of the license. */
    name?: string | undefined;
    /** SPDX license identifier. */
    spdxId?: string | undefined;
    /** URL to retrieve details about a license. */
    url?: string | undefined;
    /** Whether the license is one of the licenses featured on https://choosealicense.com */
    featured?: boolean;
}

/** The properties that repositories can be visible by. */
export enum RepositoryVisibility {
    Public = 0,
    Private = 1,
    Internal = 2,
}

/** Represents a Signature Verification Object in Git Data Commit Payload. */
export class Verification implements IVerification {
    /** Does GitHub consider the signature in this commit to be verified? */
    verified?: boolean;
    /** The reason for verified value. */
    reason?: StringEnumOfVerificationReason;
    /** The signature that was extracted from the commit. */
    signature?: string | undefined;
    /** The value that was signed. */
    payload?: string | undefined;

    constructor(data?: IVerification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.verified = _data["verified"];
            this.reason = _data["reason"] ? StringEnumOfVerificationReason.fromJS(_data["reason"]) : <any>undefined;
            this.signature = _data["signature"];
            this.payload = _data["payload"];
        }
    }

    static fromJS(data: any): Verification {
        data = typeof data === 'object' ? data : {};
        let result = new Verification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verified"] = this.verified;
        data["reason"] = this.reason ? this.reason.toJSON() : <any>undefined;
        data["signature"] = this.signature;
        data["payload"] = this.payload;
        return data; 
    }
}

/** Represents a Signature Verification Object in Git Data Commit Payload. */
export interface IVerification {
    /** Does GitHub consider the signature in this commit to be verified? */
    verified?: boolean;
    /** The reason for verified value. */
    reason?: StringEnumOfVerificationReason;
    /** The signature that was extracted from the commit. */
    signature?: string | undefined;
    /** The value that was signed. */
    payload?: string | undefined;
}

export class StringEnumOfVerificationReason implements IStringEnumOfVerificationReason {
    stringValue?: string | undefined;
    value?: VerificationReason;

    constructor(data?: IStringEnumOfVerificationReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfVerificationReason {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfVerificationReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfVerificationReason {
    stringValue?: string | undefined;
    value?: VerificationReason;
}

export enum VerificationReason {
    ExpiredKey = 0,
    NotSigningKey = 1,
    GpgVerifyError = 2,
    GpgVerifyUnavailable = 3,
    Unsigned = 4,
    UnknownSignatureType = 5,
    NoUser = 6,
    UnverifiedEmail = 7,
    BadEmail = 8,
    UnknownKey = 9,
    MalformedSignature = 10,
    Invalid = 11,
    Valid = 12,
}

/** An enhanced git commit containing links to additional resources */
export class GitHubCommitStats implements IGitHubCommitStats {
    /** The number of additions made within the commit */
    additions?: number;
    /** The number of deletions made within the commit */
    deletions?: number;
    /** The total number of modifications within the commit */
    total?: number;

    constructor(data?: IGitHubCommitStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additions = _data["additions"];
            this.deletions = _data["deletions"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GitHubCommitStats {
        data = typeof data === 'object' ? data : {};
        let result = new GitHubCommitStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["total"] = this.total;
        return data; 
    }
}

/** An enhanced git commit containing links to additional resources */
export interface IGitHubCommitStats {
    /** The number of additions made within the commit */
    additions?: number;
    /** The number of deletions made within the commit */
    deletions?: number;
    /** The total number of modifications within the commit */
    total?: number;
}

/** The affected files in a GitHubCommit. */
export class GitHubCommitFile implements IGitHubCommitFile {
    /** The name of the file */
    filename?: string | undefined;
    /** Number of additions performed on the file. */
    additions?: number;
    /** Number of deletions performed on the file. */
    deletions?: number;
    /** Number of changes performed on the file. */
    changes?: number;
    /** File status, like modified, added, deleted. */
    status?: string | undefined;
    /** The url to the file blob. */
    blobUrl?: string | undefined;
    /** The url to file contents API. */
    contentsUrl?: string | undefined;
    /** The raw url to download the file. */
    rawUrl?: string | undefined;
    /** The SHA of the file. */
    sha?: string | undefined;
    /** The patch associated with the commit */
    patch?: string | undefined;
    /** The previous filename for a renamed file. */
    previousFileName?: string | undefined;

    constructor(data?: IGitHubCommitFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filename = _data["filename"];
            this.additions = _data["additions"];
            this.deletions = _data["deletions"];
            this.changes = _data["changes"];
            this.status = _data["status"];
            this.blobUrl = _data["blobUrl"];
            this.contentsUrl = _data["contentsUrl"];
            this.rawUrl = _data["rawUrl"];
            this.sha = _data["sha"];
            this.patch = _data["patch"];
            this.previousFileName = _data["previousFileName"];
        }
    }

    static fromJS(data: any): GitHubCommitFile {
        data = typeof data === 'object' ? data : {};
        let result = new GitHubCommitFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["changes"] = this.changes;
        data["status"] = this.status;
        data["blobUrl"] = this.blobUrl;
        data["contentsUrl"] = this.contentsUrl;
        data["rawUrl"] = this.rawUrl;
        data["sha"] = this.sha;
        data["patch"] = this.patch;
        data["previousFileName"] = this.previousFileName;
        return data; 
    }
}

/** The affected files in a GitHubCommit. */
export interface IGitHubCommitFile {
    /** The name of the file */
    filename?: string | undefined;
    /** Number of additions performed on the file. */
    additions?: number;
    /** Number of deletions performed on the file. */
    deletions?: number;
    /** Number of changes performed on the file. */
    changes?: number;
    /** File status, like modified, added, deleted. */
    status?: string | undefined;
    /** The url to the file blob. */
    blobUrl?: string | undefined;
    /** The url to file contents API. */
    contentsUrl?: string | undefined;
    /** The raw url to download the file. */
    rawUrl?: string | undefined;
    /** The SHA of the file. */
    sha?: string | undefined;
    /** The patch associated with the commit */
    patch?: string | undefined;
    /** The previous filename for a renamed file. */
    previousFileName?: string | undefined;
}

export class PullFileInfo implements IPullFileInfo {
    additions?: number;
    deletions?: number;
    commitsThatIncludeFile?: number;

    constructor(data?: IPullFileInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.additions = _data["additions"];
            this.deletions = _data["deletions"];
            this.commitsThatIncludeFile = _data["commitsThatIncludeFile"];
        }
    }

    static fromJS(data: any): PullFileInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PullFileInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["commitsThatIncludeFile"] = this.commitsThatIncludeFile;
        return data; 
    }
}

export interface IPullFileInfo {
    additions?: number;
    deletions?: number;
    commitsThatIncludeFile?: number;
}

export class PullDiscussionResult implements IPullDiscussionResult {
    discussion?: IssueComment[] | undefined;
    assignedReviewers?: User[] | undefined;

    constructor(data?: IPullDiscussionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["discussion"])) {
                this.discussion = [] as any;
                for (let item of _data["discussion"])
                    this.discussion!.push(IssueComment.fromJS(item));
            }
            if (Array.isArray(_data["assignedReviewers"])) {
                this.assignedReviewers = [] as any;
                for (let item of _data["assignedReviewers"])
                    this.assignedReviewers!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PullDiscussionResult {
        data = typeof data === 'object' ? data : {};
        let result = new PullDiscussionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.discussion)) {
            data["discussion"] = [];
            for (let item of this.discussion)
                data["discussion"].push(item.toJSON());
        }
        if (Array.isArray(this.assignedReviewers)) {
            data["assignedReviewers"] = [];
            for (let item of this.assignedReviewers)
                data["assignedReviewers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPullDiscussionResult {
    discussion?: IssueComment[] | undefined;
    assignedReviewers?: User[] | undefined;
}

export class IssueComment implements IIssueComment {
    /** The issue comment Id. */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL for this issue comment. */
    url?: string | undefined;
    /** The html URL for this issue comment. */
    htmlUrl?: string | undefined;
    /** Details about the issue comment. */
    body?: string | undefined;
    /** The date the issue comment was created. */
    createdAt?: Date;
    /** The date the issue comment was last updated. */
    updatedAt?: Date | undefined;
    /** The user that created the issue comment. */
    user?: User | undefined;
    /** The comment author association with repository. */
    authorAssociation?: StringEnumOfAuthorAssociation;
    /** The reaction summary for this comment. */
    reactions?: ReactionSummary | undefined;

    constructor(data?: IIssueComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.body = _data["body"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.authorAssociation = _data["authorAssociation"] ? StringEnumOfAuthorAssociation.fromJS(_data["authorAssociation"]) : <any>undefined;
            this.reactions = _data["reactions"] ? ReactionSummary.fromJS(_data["reactions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueComment {
        data = typeof data === 'object' ? data : {};
        let result = new IssueComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["body"] = this.body;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["authorAssociation"] = this.authorAssociation ? this.authorAssociation.toJSON() : <any>undefined;
        data["reactions"] = this.reactions ? this.reactions.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIssueComment {
    /** The issue comment Id. */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL for this issue comment. */
    url?: string | undefined;
    /** The html URL for this issue comment. */
    htmlUrl?: string | undefined;
    /** Details about the issue comment. */
    body?: string | undefined;
    /** The date the issue comment was created. */
    createdAt?: Date;
    /** The date the issue comment was last updated. */
    updatedAt?: Date | undefined;
    /** The user that created the issue comment. */
    user?: User | undefined;
    /** The comment author association with repository. */
    authorAssociation?: StringEnumOfAuthorAssociation;
    /** The reaction summary for this comment. */
    reactions?: ReactionSummary | undefined;
}

export class StringEnumOfAuthorAssociation implements IStringEnumOfAuthorAssociation {
    stringValue?: string | undefined;
    value?: AuthorAssociation;

    constructor(data?: IStringEnumOfAuthorAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfAuthorAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfAuthorAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfAuthorAssociation {
    stringValue?: string | undefined;
    value?: AuthorAssociation;
}

/** States of a Team/Organization Membership */
export enum AuthorAssociation {
    Collaborator = 0,
    Contributor = 1,
    FirstTimer = 2,
    FirstTimeContributor = 3,
    Member = 4,
    Owner = 5,
    None = 6,
}

export class ReactionSummary implements IReactionSummary {
    totalCount?: number;
    plus1?: number;
    minus1?: number;
    laugh?: number;
    confused?: number;
    heart?: number;
    hooray?: number;
    url?: string | undefined;

    constructor(data?: IReactionSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.plus1 = _data["plus1"];
            this.minus1 = _data["minus1"];
            this.laugh = _data["laugh"];
            this.confused = _data["confused"];
            this.heart = _data["heart"];
            this.hooray = _data["hooray"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ReactionSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ReactionSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["plus1"] = this.plus1;
        data["minus1"] = this.minus1;
        data["laugh"] = this.laugh;
        data["confused"] = this.confused;
        data["heart"] = this.heart;
        data["hooray"] = this.hooray;
        data["url"] = this.url;
        return data; 
    }
}

export interface IReactionSummary {
    totalCount?: number;
    plus1?: number;
    minus1?: number;
    laugh?: number;
    confused?: number;
    heart?: number;
    hooray?: number;
    url?: string | undefined;
}

export class PullSummaryResponse implements IPullSummaryResponse {
    isReviewer?: boolean;

    constructor(data?: IPullSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReviewer = _data["isReviewer"];
        }
    }

    static fromJS(data: any): PullSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PullSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReviewer"] = this.isReviewer;
        return data; 
    }
}

export interface IPullSummaryResponse {
    isReviewer?: boolean;
}

export class UserRepositoryResult implements IUserRepositoryResult {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    descriptionHtml?: string | undefined;
    pullUrl?: string | undefined;
    private?: boolean;
    template?: boolean;
    collaborators?: Collaborator[] | undefined;
    lastUpdated?: Date;

    constructor(data?: IUserRepositoryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.descriptionHtml = _data["descriptionHtml"];
            this.pullUrl = _data["pullUrl"];
            this.private = _data["private"];
            this.template = _data["template"];
            if (Array.isArray(_data["collaborators"])) {
                this.collaborators = [] as any;
                for (let item of _data["collaborators"])
                    this.collaborators!.push(Collaborator.fromJS(item));
            }
            this.lastUpdated = _data["lastUpdated"] ? new Date(_data["lastUpdated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRepositoryResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserRepositoryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["descriptionHtml"] = this.descriptionHtml;
        data["pullUrl"] = this.pullUrl;
        data["private"] = this.private;
        data["template"] = this.template;
        if (Array.isArray(this.collaborators)) {
            data["collaborators"] = [];
            for (let item of this.collaborators)
                data["collaborators"].push(item.toJSON());
        }
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserRepositoryResult {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    descriptionHtml?: string | undefined;
    pullUrl?: string | undefined;
    private?: boolean;
    template?: boolean;
    collaborators?: Collaborator[] | undefined;
    lastUpdated?: Date;
}

export class Collaborator implements ICollaborator {
    name?: string | undefined;
    avatarUrl?: string | undefined;

    constructor(data?: ICollaborator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): Collaborator {
        data = typeof data === 'object' ? data : {};
        let result = new Collaborator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["avatarUrl"] = this.avatarUrl;
        return data; 
    }
}

export interface ICollaborator {
    name?: string | undefined;
    avatarUrl?: string | undefined;
}

export enum RepoFilterOptions {
    All = 1,
    Owned = 2,
    ContributedNotOwned = 3,
}

export class DetailedRepository implements IDetailedRepository {
    repository?: UserRepositoryResult | undefined;
    commits?: GitHubCommit[] | undefined;
    statistics?: RepoStatistics | undefined;
    codeOwners?: { [key: string]: string; } | undefined;
    codeOwnersLastUpdated?: Date | undefined;
    isDotNetProject?: boolean;
    cyclomaticComplexities?: { [key: string]: number; } | undefined;
    cyclomaticComplexitiesLastUpdated?: Date | undefined;
    staticAnalysisLastUpdated?: Date | undefined;
    staticAnalysisHtml?: string | undefined;

    constructor(data?: IDetailedRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repository = _data["repository"] ? UserRepositoryResult.fromJS(_data["repository"]) : <any>undefined;
            if (Array.isArray(_data["commits"])) {
                this.commits = [] as any;
                for (let item of _data["commits"])
                    this.commits!.push(GitHubCommit.fromJS(item));
            }
            this.statistics = _data["statistics"] ? RepoStatistics.fromJS(_data["statistics"]) : <any>undefined;
            if (_data["codeOwners"]) {
                this.codeOwners = {} as any;
                for (let key in _data["codeOwners"]) {
                    if (_data["codeOwners"].hasOwnProperty(key))
                        (<any>this.codeOwners)![key] = _data["codeOwners"][key];
                }
            }
            this.codeOwnersLastUpdated = _data["codeOwnersLastUpdated"] ? new Date(_data["codeOwnersLastUpdated"].toString()) : <any>undefined;
            this.isDotNetProject = _data["isDotNetProject"];
            if (_data["cyclomaticComplexities"]) {
                this.cyclomaticComplexities = {} as any;
                for (let key in _data["cyclomaticComplexities"]) {
                    if (_data["cyclomaticComplexities"].hasOwnProperty(key))
                        (<any>this.cyclomaticComplexities)![key] = _data["cyclomaticComplexities"][key];
                }
            }
            this.cyclomaticComplexitiesLastUpdated = _data["cyclomaticComplexitiesLastUpdated"] ? new Date(_data["cyclomaticComplexitiesLastUpdated"].toString()) : <any>undefined;
            this.staticAnalysisLastUpdated = _data["staticAnalysisLastUpdated"] ? new Date(_data["staticAnalysisLastUpdated"].toString()) : <any>undefined;
            this.staticAnalysisHtml = _data["staticAnalysisHtml"];
        }
    }

    static fromJS(data: any): DetailedRepository {
        data = typeof data === 'object' ? data : {};
        let result = new DetailedRepository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        if (Array.isArray(this.commits)) {
            data["commits"] = [];
            for (let item of this.commits)
                data["commits"].push(item.toJSON());
        }
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>undefined;
        if (this.codeOwners) {
            data["codeOwners"] = {};
            for (let key in this.codeOwners) {
                if (this.codeOwners.hasOwnProperty(key))
                    (<any>data["codeOwners"])[key] = this.codeOwners[key];
            }
        }
        data["codeOwnersLastUpdated"] = this.codeOwnersLastUpdated ? this.codeOwnersLastUpdated.toISOString() : <any>undefined;
        data["isDotNetProject"] = this.isDotNetProject;
        if (this.cyclomaticComplexities) {
            data["cyclomaticComplexities"] = {};
            for (let key in this.cyclomaticComplexities) {
                if (this.cyclomaticComplexities.hasOwnProperty(key))
                    (<any>data["cyclomaticComplexities"])[key] = this.cyclomaticComplexities[key];
            }
        }
        data["cyclomaticComplexitiesLastUpdated"] = this.cyclomaticComplexitiesLastUpdated ? this.cyclomaticComplexitiesLastUpdated.toISOString() : <any>undefined;
        data["staticAnalysisLastUpdated"] = this.staticAnalysisLastUpdated ? this.staticAnalysisLastUpdated.toISOString() : <any>undefined;
        data["staticAnalysisHtml"] = this.staticAnalysisHtml;
        return data; 
    }
}

export interface IDetailedRepository {
    repository?: UserRepositoryResult | undefined;
    commits?: GitHubCommit[] | undefined;
    statistics?: RepoStatistics | undefined;
    codeOwners?: { [key: string]: string; } | undefined;
    codeOwnersLastUpdated?: Date | undefined;
    isDotNetProject?: boolean;
    cyclomaticComplexities?: { [key: string]: number; } | undefined;
    cyclomaticComplexitiesLastUpdated?: Date | undefined;
    staticAnalysisLastUpdated?: Date | undefined;
    staticAnalysisHtml?: string | undefined;
}

export class RepoStatistics implements IRepoStatistics {
    codeFrequency?: CodeFrequency | undefined;
    commitActivity?: CommitActivity | undefined;
    participation?: Participation | undefined;
    commitPunchCard?: PunchCard | undefined;

    constructor(data?: IRepoStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.codeFrequency = _data["codeFrequency"] ? CodeFrequency.fromJS(_data["codeFrequency"]) : <any>undefined;
            this.commitActivity = _data["commitActivity"] ? CommitActivity.fromJS(_data["commitActivity"]) : <any>undefined;
            this.participation = _data["participation"] ? Participation.fromJS(_data["participation"]) : <any>undefined;
            this.commitPunchCard = _data["commitPunchCard"] ? PunchCard.fromJS(_data["commitPunchCard"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RepoStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new RepoStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["codeFrequency"] = this.codeFrequency ? this.codeFrequency.toJSON() : <any>undefined;
        data["commitActivity"] = this.commitActivity ? this.commitActivity.toJSON() : <any>undefined;
        data["participation"] = this.participation ? this.participation.toJSON() : <any>undefined;
        data["commitPunchCard"] = this.commitPunchCard ? this.commitPunchCard.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRepoStatistics {
    codeFrequency?: CodeFrequency | undefined;
    commitActivity?: CommitActivity | undefined;
    participation?: Participation | undefined;
    commitPunchCard?: PunchCard | undefined;
}

/** Represents the summary of lines added and deleted */
export class CodeFrequency implements ICodeFrequency {
    /** A weekly aggregate of the number of additions and deletions pushed to a repository. */
    additionsAndDeletionsByWeek?: AdditionsAndDeletions[] | undefined;

    constructor(data?: ICodeFrequency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["additionsAndDeletionsByWeek"])) {
                this.additionsAndDeletionsByWeek = [] as any;
                for (let item of _data["additionsAndDeletionsByWeek"])
                    this.additionsAndDeletionsByWeek!.push(AdditionsAndDeletions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CodeFrequency {
        data = typeof data === 'object' ? data : {};
        let result = new CodeFrequency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.additionsAndDeletionsByWeek)) {
            data["additionsAndDeletionsByWeek"] = [];
            for (let item of this.additionsAndDeletionsByWeek)
                data["additionsAndDeletionsByWeek"].push(item.toJSON());
        }
        return data; 
    }
}

/** Represents the summary of lines added and deleted */
export interface ICodeFrequency {
    /** A weekly aggregate of the number of additions and deletions pushed to a repository. */
    additionsAndDeletionsByWeek?: AdditionsAndDeletions[] | undefined;
}

/** Represents lines added and deleted at a given point in time */
export class AdditionsAndDeletions implements IAdditionsAndDeletions {
    /** Date of the recorded activity */
    timestamp?: Date;
    /** Lines added for the given day */
    additions?: number;
    /** Lines deleted for the given day */
    deletions?: number;

    constructor(data?: IAdditionsAndDeletions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.additions = _data["additions"];
            this.deletions = _data["deletions"];
        }
    }

    static fromJS(data: any): AdditionsAndDeletions {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionsAndDeletions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        return data; 
    }
}

/** Represents lines added and deleted at a given point in time */
export interface IAdditionsAndDeletions {
    /** Date of the recorded activity */
    timestamp?: Date;
    /** Lines added for the given day */
    additions?: number;
    /** Lines deleted for the given day */
    deletions?: number;
}

export class CommitActivity implements ICommitActivity {
    /** Returns the last year of commit activity grouped by week. */
    activity?: WeeklyCommitActivity[] | undefined;

    constructor(data?: ICommitActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activity"])) {
                this.activity = [] as any;
                for (let item of _data["activity"])
                    this.activity!.push(WeeklyCommitActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommitActivity {
        data = typeof data === 'object' ? data : {};
        let result = new CommitActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activity)) {
            data["activity"] = [];
            for (let item of this.activity)
                data["activity"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICommitActivity {
    /** Returns the last year of commit activity grouped by week. */
    activity?: WeeklyCommitActivity[] | undefined;
}

export class WeeklyCommitActivity implements IWeeklyCommitActivity {
    /** The days array is a group of commits per day, starting on Sunday. */
    days?: number[] | undefined;
    /** Totally number of commits made this week. */
    total?: number;
    /** The week of commits */
    week?: number;
    weekTimestamp?: Date;

    constructor(data?: IWeeklyCommitActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["days"])) {
                this.days = [] as any;
                for (let item of _data["days"])
                    this.days!.push(item);
            }
            this.total = _data["total"];
            this.week = _data["week"];
            this.weekTimestamp = _data["weekTimestamp"] ? new Date(_data["weekTimestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WeeklyCommitActivity {
        data = typeof data === 'object' ? data : {};
        let result = new WeeklyCommitActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.days)) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item);
        }
        data["total"] = this.total;
        data["week"] = this.week;
        data["weekTimestamp"] = this.weekTimestamp ? this.weekTimestamp.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IWeeklyCommitActivity {
    /** The days array is a group of commits per day, starting on Sunday. */
    days?: number[] | undefined;
    /** Totally number of commits made this week. */
    total?: number;
    /** The week of commits */
    week?: number;
    weekTimestamp?: Date;
}

/** Returns the total commit counts for the owner and total commit counts in total in the last 52 weeks */
export class Participation implements IParticipation {
    /** Returns the commit counts made each week, for the last 52 weeks */
    all?: number[] | undefined;
    /** Returns the commit counts made by the owner each week, for the last 52 weeks */
    owner?: number[] | undefined;

    constructor(data?: IParticipation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["all"])) {
                this.all = [] as any;
                for (let item of _data["all"])
                    this.all!.push(item);
            }
            if (Array.isArray(_data["owner"])) {
                this.owner = [] as any;
                for (let item of _data["owner"])
                    this.owner!.push(item);
            }
        }
    }

    static fromJS(data: any): Participation {
        data = typeof data === 'object' ? data : {};
        let result = new Participation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.all)) {
            data["all"] = [];
            for (let item of this.all)
                data["all"].push(item);
        }
        if (Array.isArray(this.owner)) {
            data["owner"] = [];
            for (let item of this.owner)
                data["owner"].push(item);
        }
        return data; 
    }
}

/** Returns the total commit counts for the owner and total commit counts in total in the last 52 weeks */
export interface IParticipation {
    /** Returns the commit counts made each week, for the last 52 weeks */
    all?: number[] | undefined;
    /** Returns the commit counts made by the owner each week, for the last 52 weeks */
    owner?: number[] | undefined;
}

export class PunchCard implements IPunchCard {
    /** The raw punch card points */
    punchPoints?: PunchCardPoint[] | undefined;

    constructor(data?: IPunchCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["punchPoints"])) {
                this.punchPoints = [] as any;
                for (let item of _data["punchPoints"])
                    this.punchPoints!.push(PunchCardPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PunchCard {
        data = typeof data === 'object' ? data : {};
        let result = new PunchCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.punchPoints)) {
            data["punchPoints"] = [];
            for (let item of this.punchPoints)
                data["punchPoints"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPunchCard {
    /** The raw punch card points */
    punchPoints?: PunchCardPoint[] | undefined;
}

export class PunchCardPoint implements IPunchCardPoint {
    dayOfWeek?: StringEnumOfDayOfWeek;
    hourOfTheDay?: number;
    commitCount?: number;

    constructor(data?: IPunchCardPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dayOfWeek = _data["dayOfWeek"] ? StringEnumOfDayOfWeek.fromJS(_data["dayOfWeek"]) : <any>undefined;
            this.hourOfTheDay = _data["hourOfTheDay"];
            this.commitCount = _data["commitCount"];
        }
    }

    static fromJS(data: any): PunchCardPoint {
        data = typeof data === 'object' ? data : {};
        let result = new PunchCardPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dayOfWeek"] = this.dayOfWeek ? this.dayOfWeek.toJSON() : <any>undefined;
        data["hourOfTheDay"] = this.hourOfTheDay;
        data["commitCount"] = this.commitCount;
        return data; 
    }
}

export interface IPunchCardPoint {
    dayOfWeek?: StringEnumOfDayOfWeek;
    hourOfTheDay?: number;
    commitCount?: number;
}

export class StringEnumOfDayOfWeek implements IStringEnumOfDayOfWeek {
    stringValue?: string | undefined;
    value?: DayOfWeek;

    constructor(data?: IStringEnumOfDayOfWeek) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfDayOfWeek {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfDayOfWeek();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfDayOfWeek {
    stringValue?: string | undefined;
    value?: DayOfWeek;
}

export enum DayOfWeek {
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
}

export class CyclomaticComplexityRequest implements ICyclomaticComplexityRequest {
    filesToSearch?: string[] | undefined;
    repoId?: number;
    pullRequestNumber?: number | undefined;

    constructor(data?: ICyclomaticComplexityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["filesToSearch"])) {
                this.filesToSearch = [] as any;
                for (let item of _data["filesToSearch"])
                    this.filesToSearch!.push(item);
            }
            this.repoId = _data["repoId"];
            this.pullRequestNumber = _data["pullRequestNumber"];
        }
    }

    static fromJS(data: any): CyclomaticComplexityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CyclomaticComplexityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filesToSearch)) {
            data["filesToSearch"] = [];
            for (let item of this.filesToSearch)
                data["filesToSearch"].push(item);
        }
        data["repoId"] = this.repoId;
        data["pullRequestNumber"] = this.pullRequestNumber;
        return data; 
    }
}

export interface ICyclomaticComplexityRequest {
    filesToSearch?: string[] | undefined;
    repoId?: number;
    pullRequestNumber?: number | undefined;
}

export class RepoIssuesResponse implements IRepoIssuesResponse {
    issues?: Issue[] | undefined;

    constructor(data?: IRepoIssuesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(Issue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RepoIssuesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RepoIssuesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRepoIssuesResponse {
    issues?: Issue[] | undefined;
}

export class Issue implements IIssue {
    /** The internal Id for this issue (not the issue number) */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL for this issue. */
    url?: string | undefined;
    /** The URL for the HTML view of this issue. */
    htmlUrl?: string | undefined;
    /** The Comments URL of this issue. */
    commentsUrl?: string | undefined;
    /** The Events URL of this issue. */
    eventsUrl?: string | undefined;
    /** The issue number. */
    number?: number;
    /** Whether the issue is open or closed. */
    state?: StringEnumOfItemState;
    /** Title of the issue */
    title?: string | undefined;
    /** Details about the issue. */
    body?: string | undefined;
    /** Details about the user who has closed this issue. */
    closedBy?: User | undefined;
    /** The user that created the issue. */
    user?: User | undefined;
    /** The set of labels applied to the issue */
    labels?: Label[] | undefined;
    /** The user this issue is assigned to. */
    assignee?: User | undefined;
    /** The multiple users this issue is assigned to.
  */
    assignees?: User[] | undefined;
    /** The milestone, if any, that this issue is assigned to. */
    milestone?: Milestone | undefined;
    /** The number of comments on the issue. */
    comments?: number;
    pullRequest?: PullRequest | undefined;
    /** The date the issue was closed if closed. */
    closedAt?: Date | undefined;
    /** The date the issue was created. */
    createdAt?: Date;
    /** The date the issue was last updated. */
    updatedAt?: Date | undefined;
    /** If the issue is locked or not. */
    locked?: boolean;
    /** The repository the issue comes from. */
    repository?: Repository | undefined;
    /** The reaction summary for this issue. */
    reactions?: ReactionSummary | undefined;

    constructor(data?: IIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.commentsUrl = _data["commentsUrl"];
            this.eventsUrl = _data["eventsUrl"];
            this.number = _data["number"];
            this.state = _data["state"] ? StringEnumOfItemState.fromJS(_data["state"]) : <any>undefined;
            this.title = _data["title"];
            this.body = _data["body"];
            this.closedBy = _data["closedBy"] ? User.fromJS(_data["closedBy"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(Label.fromJS(item));
            }
            this.assignee = _data["assignee"] ? User.fromJS(_data["assignee"]) : <any>undefined;
            if (Array.isArray(_data["assignees"])) {
                this.assignees = [] as any;
                for (let item of _data["assignees"])
                    this.assignees!.push(User.fromJS(item));
            }
            this.milestone = _data["milestone"] ? Milestone.fromJS(_data["milestone"]) : <any>undefined;
            this.comments = _data["comments"];
            this.pullRequest = _data["pullRequest"] ? PullRequest.fromJS(_data["pullRequest"]) : <any>undefined;
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.locked = _data["locked"];
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
            this.reactions = _data["reactions"] ? ReactionSummary.fromJS(_data["reactions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Issue {
        data = typeof data === 'object' ? data : {};
        let result = new Issue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["commentsUrl"] = this.commentsUrl;
        data["eventsUrl"] = this.eventsUrl;
        data["number"] = this.number;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["body"] = this.body;
        data["closedBy"] = this.closedBy ? this.closedBy.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        if (Array.isArray(this.assignees)) {
            data["assignees"] = [];
            for (let item of this.assignees)
                data["assignees"].push(item.toJSON());
        }
        data["milestone"] = this.milestone ? this.milestone.toJSON() : <any>undefined;
        data["comments"] = this.comments;
        data["pullRequest"] = this.pullRequest ? this.pullRequest.toJSON() : <any>undefined;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["locked"] = this.locked;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["reactions"] = this.reactions ? this.reactions.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIssue {
    /** The internal Id for this issue (not the issue number) */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL for this issue. */
    url?: string | undefined;
    /** The URL for the HTML view of this issue. */
    htmlUrl?: string | undefined;
    /** The Comments URL of this issue. */
    commentsUrl?: string | undefined;
    /** The Events URL of this issue. */
    eventsUrl?: string | undefined;
    /** The issue number. */
    number?: number;
    /** Whether the issue is open or closed. */
    state?: StringEnumOfItemState;
    /** Title of the issue */
    title?: string | undefined;
    /** Details about the issue. */
    body?: string | undefined;
    /** Details about the user who has closed this issue. */
    closedBy?: User | undefined;
    /** The user that created the issue. */
    user?: User | undefined;
    /** The set of labels applied to the issue */
    labels?: Label[] | undefined;
    /** The user this issue is assigned to. */
    assignee?: User | undefined;
    /** The multiple users this issue is assigned to.
  */
    assignees?: User[] | undefined;
    /** The milestone, if any, that this issue is assigned to. */
    milestone?: Milestone | undefined;
    /** The number of comments on the issue. */
    comments?: number;
    pullRequest?: PullRequest | undefined;
    /** The date the issue was closed if closed. */
    closedAt?: Date | undefined;
    /** The date the issue was created. */
    createdAt?: Date;
    /** The date the issue was last updated. */
    updatedAt?: Date | undefined;
    /** If the issue is locked or not. */
    locked?: boolean;
    /** The repository the issue comes from. */
    repository?: Repository | undefined;
    /** The reaction summary for this issue. */
    reactions?: ReactionSummary | undefined;
}

export class StringEnumOfItemState implements IStringEnumOfItemState {
    stringValue?: string | undefined;
    value?: ItemState;

    constructor(data?: IStringEnumOfItemState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfItemState {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfItemState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfItemState {
    stringValue?: string | undefined;
    value?: ItemState;
}

/** Items that are open OR closed */
export enum ItemState {
    Open = 0,
    Closed = 1,
}

export class Label implements ILabel {
    /** Id of the label */
    id?: number;
    /** Url of the label */
    url?: string | undefined;
    /** Name of the label */
    name?: string | undefined;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Color of the label */
    color?: string | undefined;
    /** Description of the label */
    description?: string | undefined;
    /** Is default label */
    default?: boolean;

    constructor(data?: ILabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.name = _data["name"];
            this.nodeId = _data["nodeId"];
            this.color = _data["color"];
            this.description = _data["description"];
            this.default = _data["default"];
        }
    }

    static fromJS(data: any): Label {
        data = typeof data === 'object' ? data : {};
        let result = new Label();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["name"] = this.name;
        data["nodeId"] = this.nodeId;
        data["color"] = this.color;
        data["description"] = this.description;
        data["default"] = this.default;
        return data; 
    }
}

export interface ILabel {
    /** Id of the label */
    id?: number;
    /** Url of the label */
    url?: string | undefined;
    /** Name of the label */
    name?: string | undefined;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Color of the label */
    color?: string | undefined;
    /** Description of the label */
    description?: string | undefined;
    /** Is default label */
    default?: boolean;
}

export class Milestone implements IMilestone {
    /** The URL for this milestone. */
    url?: string | undefined;
    /** The Html page for this milestone. */
    htmlUrl?: string | undefined;
    /** The ID for this milestone. */
    id?: number;
    /** The milestone number. */
    number?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Whether the milestone is open or closed. */
    state?: StringEnumOfItemState;
    /** Title of the milestone. */
    title?: string | undefined;
    /** Optional description for the milestone. */
    description?: string | undefined;
    /** The user that created this milestone. */
    creator?: User | undefined;
    /** The number of open issues in this milestone. */
    openIssues?: number;
    /** The number of closed issues in this milestone. */
    closedIssues?: number;
    /** The date this milestone was created. */
    createdAt?: Date;
    /** The date, if any, when this milestone is due. */
    dueOn?: Date | undefined;
    /** The date, if any, when this milestone was closed. */
    closedAt?: Date | undefined;
    /** The date, if any, when this milestone was updated. */
    updatedAt?: Date | undefined;

    constructor(data?: IMilestone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.id = _data["id"];
            this.number = _data["number"];
            this.nodeId = _data["nodeId"];
            this.state = _data["state"] ? StringEnumOfItemState.fromJS(_data["state"]) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            this.openIssues = _data["openIssues"];
            this.closedIssues = _data["closedIssues"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.dueOn = _data["dueOn"] ? new Date(_data["dueOn"].toString()) : <any>undefined;
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Milestone {
        data = typeof data === 'object' ? data : {};
        let result = new Milestone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["id"] = this.id;
        data["number"] = this.number;
        data["nodeId"] = this.nodeId;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["openIssues"] = this.openIssues;
        data["closedIssues"] = this.closedIssues;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["dueOn"] = this.dueOn ? this.dueOn.toISOString() : <any>undefined;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMilestone {
    /** The URL for this milestone. */
    url?: string | undefined;
    /** The Html page for this milestone. */
    htmlUrl?: string | undefined;
    /** The ID for this milestone. */
    id?: number;
    /** The milestone number. */
    number?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** Whether the milestone is open or closed. */
    state?: StringEnumOfItemState;
    /** Title of the milestone. */
    title?: string | undefined;
    /** Optional description for the milestone. */
    description?: string | undefined;
    /** The user that created this milestone. */
    creator?: User | undefined;
    /** The number of open issues in this milestone. */
    openIssues?: number;
    /** The number of closed issues in this milestone. */
    closedIssues?: number;
    /** The date this milestone was created. */
    createdAt?: Date;
    /** The date, if any, when this milestone is due. */
    dueOn?: Date | undefined;
    /** The date, if any, when this milestone was closed. */
    closedAt?: Date | undefined;
    /** The date, if any, when this milestone was updated. */
    updatedAt?: Date | undefined;
}

export class PullRequest implements IPullRequest {
    /** The internal Id for this pull request (not the pull request number) */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL for this pull request. */
    url?: string | undefined;
    /** The URL for the pull request page. */
    htmlUrl?: string | undefined;
    /** The URL for the pull request's diff (.diff) file. */
    diffUrl?: string | undefined;
    /** The URL for the pull request's patch (.patch) file. */
    patchUrl?: string | undefined;
    /** The URL for the specific pull request issue. */
    issueUrl?: string | undefined;
    /** The URL for the pull request statuses. */
    statusesUrl?: string | undefined;
    /** The pull request number. */
    number?: number;
    /** Whether the pull request is open or closed. The default is Open. */
    state?: StringEnumOfItemState;
    /** Title of the pull request. */
    title?: string | undefined;
    /** The body (content) contained within the pull request. */
    body?: string | undefined;
    /** When the pull request was created. */
    createdAt?: Date;
    /** When the pull request was last updated. */
    updatedAt?: Date;
    /** When the pull request was closed. */
    closedAt?: Date | undefined;
    /** When the pull request was merged. */
    mergedAt?: Date | undefined;
    /** The HEAD reference for the pull request. */
    head?: GitReference | undefined;
    /** The BASE reference for the pull request. */
    base?: GitReference | undefined;
    /** The user who created the pull request. */
    user?: User | undefined;
    /** The user who is assigned the pull request. */
    assignee?: User | undefined;
    /** The multiple users this pull request is assigned to.
  */
    assignees?: User[] | undefined;
    /** The milestone, if any, that this pull request is assigned to. */
    milestone?: Milestone | undefined;
    /** Whether or not the pull request is in a draft state, and cannot be merged. */
    draft?: boolean;
    /** Whether or not the pull request has been merged. */
    merged?: boolean;
    /** Whether or not the pull request can be merged. */
    mergeable?: boolean | undefined;
    /** Provides extra information regarding the mergeability of the pull request. */
    mergeableState?: StringEnumOfMergeableState | undefined;
    /** The user who merged the pull request. */
    mergedBy?: User | undefined;
    /** The value of this field changes depending on the state of the pull request.
Not Merged - the hash of the test commit used to determine mergeability.
Merged with merge commit - the hash of said merge commit.
Merged via squashing - the hash of the squashed commit added to the base branch.
Merged via rebase - the hash of the commit that the base branch was updated to. */
    mergeCommitSha?: string | undefined;
    /** Total number of comments contained in the pull request. */
    comments?: number;
    /** Total number of commits contained in the pull request. */
    commits?: number;
    /** Total number of additions contained in the pull request. */
    additions?: number;
    /** Total number of deletions contained in the pull request. */
    deletions?: number;
    /** Total number of files changed in the pull request. */
    changedFiles?: number;
    /** If the issue is locked or not */
    locked?: boolean;
    /** Whether maintainers of the base repository can push to the HEAD branch */
    maintainerCanModify?: boolean | undefined;
    /** Users requested for review */
    requestedReviewers?: User[] | undefined;
    /** Teams requested for review */
    requestedTeams?: Team[] | undefined;
    labels?: Label[] | undefined;

    constructor(data?: IPullRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.diffUrl = _data["diffUrl"];
            this.patchUrl = _data["patchUrl"];
            this.issueUrl = _data["issueUrl"];
            this.statusesUrl = _data["statusesUrl"];
            this.number = _data["number"];
            this.state = _data["state"] ? StringEnumOfItemState.fromJS(_data["state"]) : <any>undefined;
            this.title = _data["title"];
            this.body = _data["body"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.closedAt = _data["closedAt"] ? new Date(_data["closedAt"].toString()) : <any>undefined;
            this.mergedAt = _data["mergedAt"] ? new Date(_data["mergedAt"].toString()) : <any>undefined;
            this.head = _data["head"] ? GitReference.fromJS(_data["head"]) : <any>undefined;
            this.base = _data["base"] ? GitReference.fromJS(_data["base"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.assignee = _data["assignee"] ? User.fromJS(_data["assignee"]) : <any>undefined;
            if (Array.isArray(_data["assignees"])) {
                this.assignees = [] as any;
                for (let item of _data["assignees"])
                    this.assignees!.push(User.fromJS(item));
            }
            this.milestone = _data["milestone"] ? Milestone.fromJS(_data["milestone"]) : <any>undefined;
            this.draft = _data["draft"];
            this.merged = _data["merged"];
            this.mergeable = _data["mergeable"];
            this.mergeableState = _data["mergeableState"] ? StringEnumOfMergeableState.fromJS(_data["mergeableState"]) : <any>undefined;
            this.mergedBy = _data["mergedBy"] ? User.fromJS(_data["mergedBy"]) : <any>undefined;
            this.mergeCommitSha = _data["mergeCommitSha"];
            this.comments = _data["comments"];
            this.commits = _data["commits"];
            this.additions = _data["additions"];
            this.deletions = _data["deletions"];
            this.changedFiles = _data["changedFiles"];
            this.locked = _data["locked"];
            this.maintainerCanModify = _data["maintainerCanModify"];
            if (Array.isArray(_data["requestedReviewers"])) {
                this.requestedReviewers = [] as any;
                for (let item of _data["requestedReviewers"])
                    this.requestedReviewers!.push(User.fromJS(item));
            }
            if (Array.isArray(_data["requestedTeams"])) {
                this.requestedTeams = [] as any;
                for (let item of _data["requestedTeams"])
                    this.requestedTeams!.push(Team.fromJS(item));
            }
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(Label.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PullRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PullRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["diffUrl"] = this.diffUrl;
        data["patchUrl"] = this.patchUrl;
        data["issueUrl"] = this.issueUrl;
        data["statusesUrl"] = this.statusesUrl;
        data["number"] = this.number;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["body"] = this.body;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["closedAt"] = this.closedAt ? this.closedAt.toISOString() : <any>undefined;
        data["mergedAt"] = this.mergedAt ? this.mergedAt.toISOString() : <any>undefined;
        data["head"] = this.head ? this.head.toJSON() : <any>undefined;
        data["base"] = this.base ? this.base.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        if (Array.isArray(this.assignees)) {
            data["assignees"] = [];
            for (let item of this.assignees)
                data["assignees"].push(item.toJSON());
        }
        data["milestone"] = this.milestone ? this.milestone.toJSON() : <any>undefined;
        data["draft"] = this.draft;
        data["merged"] = this.merged;
        data["mergeable"] = this.mergeable;
        data["mergeableState"] = this.mergeableState ? this.mergeableState.toJSON() : <any>undefined;
        data["mergedBy"] = this.mergedBy ? this.mergedBy.toJSON() : <any>undefined;
        data["mergeCommitSha"] = this.mergeCommitSha;
        data["comments"] = this.comments;
        data["commits"] = this.commits;
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["changedFiles"] = this.changedFiles;
        data["locked"] = this.locked;
        data["maintainerCanModify"] = this.maintainerCanModify;
        if (Array.isArray(this.requestedReviewers)) {
            data["requestedReviewers"] = [];
            for (let item of this.requestedReviewers)
                data["requestedReviewers"].push(item.toJSON());
        }
        if (Array.isArray(this.requestedTeams)) {
            data["requestedTeams"] = [];
            for (let item of this.requestedTeams)
                data["requestedTeams"].push(item.toJSON());
        }
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPullRequest {
    /** The internal Id for this pull request (not the pull request number) */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** The URL for this pull request. */
    url?: string | undefined;
    /** The URL for the pull request page. */
    htmlUrl?: string | undefined;
    /** The URL for the pull request's diff (.diff) file. */
    diffUrl?: string | undefined;
    /** The URL for the pull request's patch (.patch) file. */
    patchUrl?: string | undefined;
    /** The URL for the specific pull request issue. */
    issueUrl?: string | undefined;
    /** The URL for the pull request statuses. */
    statusesUrl?: string | undefined;
    /** The pull request number. */
    number?: number;
    /** Whether the pull request is open or closed. The default is Open. */
    state?: StringEnumOfItemState;
    /** Title of the pull request. */
    title?: string | undefined;
    /** The body (content) contained within the pull request. */
    body?: string | undefined;
    /** When the pull request was created. */
    createdAt?: Date;
    /** When the pull request was last updated. */
    updatedAt?: Date;
    /** When the pull request was closed. */
    closedAt?: Date | undefined;
    /** When the pull request was merged. */
    mergedAt?: Date | undefined;
    /** The HEAD reference for the pull request. */
    head?: GitReference | undefined;
    /** The BASE reference for the pull request. */
    base?: GitReference | undefined;
    /** The user who created the pull request. */
    user?: User | undefined;
    /** The user who is assigned the pull request. */
    assignee?: User | undefined;
    /** The multiple users this pull request is assigned to.
  */
    assignees?: User[] | undefined;
    /** The milestone, if any, that this pull request is assigned to. */
    milestone?: Milestone | undefined;
    /** Whether or not the pull request is in a draft state, and cannot be merged. */
    draft?: boolean;
    /** Whether or not the pull request has been merged. */
    merged?: boolean;
    /** Whether or not the pull request can be merged. */
    mergeable?: boolean | undefined;
    /** Provides extra information regarding the mergeability of the pull request. */
    mergeableState?: StringEnumOfMergeableState | undefined;
    /** The user who merged the pull request. */
    mergedBy?: User | undefined;
    /** The value of this field changes depending on the state of the pull request.
Not Merged - the hash of the test commit used to determine mergeability.
Merged with merge commit - the hash of said merge commit.
Merged via squashing - the hash of the squashed commit added to the base branch.
Merged via rebase - the hash of the commit that the base branch was updated to. */
    mergeCommitSha?: string | undefined;
    /** Total number of comments contained in the pull request. */
    comments?: number;
    /** Total number of commits contained in the pull request. */
    commits?: number;
    /** Total number of additions contained in the pull request. */
    additions?: number;
    /** Total number of deletions contained in the pull request. */
    deletions?: number;
    /** Total number of files changed in the pull request. */
    changedFiles?: number;
    /** If the issue is locked or not */
    locked?: boolean;
    /** Whether maintainers of the base repository can push to the HEAD branch */
    maintainerCanModify?: boolean | undefined;
    /** Users requested for review */
    requestedReviewers?: User[] | undefined;
    /** Teams requested for review */
    requestedTeams?: Team[] | undefined;
    labels?: Label[] | undefined;
}

export class StringEnumOfMergeableState implements IStringEnumOfMergeableState {
    stringValue?: string | undefined;
    value?: MergeableState;

    constructor(data?: IStringEnumOfMergeableState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfMergeableState {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfMergeableState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfMergeableState {
    stringValue?: string | undefined;
    value?: MergeableState;
}

/** Provides extra information regarding the mergeability of a pull request */
export enum MergeableState {
    Dirty = 0,
    Unknown = 1,
    Blocked = 2,
    Behind = 3,
    Unstable = 4,
    HasHooks = 5,
    Clean = 6,
}

/** organization teams */
export class Team implements ITeam {
    /** url for this team */
    url?: string | undefined;
    /** The HTML URL for this team. */
    htmlUrl?: string | undefined;
    /** team id */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** team slug */
    slug?: string | undefined;
    /** team name */
    name?: string | undefined;
    /** team description */
    description?: string | undefined;
    /** team privacy */
    privacy?: StringEnumOfTeamPrivacy;
    /** permission attached to this team */
    permission?: StringEnumOfPermissionLevel;
    /** how many members in this team */
    membersCount?: number;
    /** how many repo this team has access to */
    reposCount?: number;
    /** who this team belongs to */
    organization?: Organization | undefined;
    /** The parent team */
    parent?: Team | undefined;
    /** LDAP Binding (GitHub Enterprise only) */
    ldapDistinguishedName?: string | undefined;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.htmlUrl = _data["htmlUrl"];
            this.id = _data["id"];
            this.nodeId = _data["nodeId"];
            this.slug = _data["slug"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.privacy = _data["privacy"] ? StringEnumOfTeamPrivacy.fromJS(_data["privacy"]) : <any>undefined;
            this.permission = _data["permission"] ? StringEnumOfPermissionLevel.fromJS(_data["permission"]) : <any>undefined;
            this.membersCount = _data["membersCount"];
            this.reposCount = _data["reposCount"];
            this.organization = _data["organization"] ? Organization.fromJS(_data["organization"]) : <any>undefined;
            this.parent = _data["parent"] ? Team.fromJS(_data["parent"]) : <any>undefined;
            this.ldapDistinguishedName = _data["ldapDistinguishedName"];
        }
    }

    static fromJS(data: any): Team {
        data = typeof data === 'object' ? data : {};
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["htmlUrl"] = this.htmlUrl;
        data["id"] = this.id;
        data["nodeId"] = this.nodeId;
        data["slug"] = this.slug;
        data["name"] = this.name;
        data["description"] = this.description;
        data["privacy"] = this.privacy ? this.privacy.toJSON() : <any>undefined;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        data["membersCount"] = this.membersCount;
        data["reposCount"] = this.reposCount;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["ldapDistinguishedName"] = this.ldapDistinguishedName;
        return data; 
    }
}

/** organization teams */
export interface ITeam {
    /** url for this team */
    url?: string | undefined;
    /** The HTML URL for this team. */
    htmlUrl?: string | undefined;
    /** team id */
    id?: number;
    /** GraphQL Node Id */
    nodeId?: string | undefined;
    /** team slug */
    slug?: string | undefined;
    /** team name */
    name?: string | undefined;
    /** team description */
    description?: string | undefined;
    /** team privacy */
    privacy?: StringEnumOfTeamPrivacy;
    /** permission attached to this team */
    permission?: StringEnumOfPermissionLevel;
    /** how many members in this team */
    membersCount?: number;
    /** how many repo this team has access to */
    reposCount?: number;
    /** who this team belongs to */
    organization?: Organization | undefined;
    /** The parent team */
    parent?: Team | undefined;
    /** LDAP Binding (GitHub Enterprise only) */
    ldapDistinguishedName?: string | undefined;
}

export class StringEnumOfTeamPrivacy implements IStringEnumOfTeamPrivacy {
    stringValue?: string | undefined;
    value?: TeamPrivacy;

    constructor(data?: IStringEnumOfTeamPrivacy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfTeamPrivacy {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfTeamPrivacy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfTeamPrivacy {
    stringValue?: string | undefined;
    value?: TeamPrivacy;
}

/** Used to describe a team's privacy level. */
export enum TeamPrivacy {
    Secret = 0,
    Closed = 1,
}

export class StringEnumOfPermissionLevel implements IStringEnumOfPermissionLevel {
    stringValue?: string | undefined;
    value?: PermissionLevel;

    constructor(data?: IStringEnumOfPermissionLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stringValue = _data["stringValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StringEnumOfPermissionLevel {
        data = typeof data === 'object' ? data : {};
        let result = new StringEnumOfPermissionLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stringValue"] = this.stringValue;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStringEnumOfPermissionLevel {
    stringValue?: string | undefined;
    value?: PermissionLevel;
}

export enum PermissionLevel {
    Admin = 0,
    Write = 1,
    Read = 2,
    None = 3,
}

export class Organization extends Account implements IOrganization {
    /** The billing address for an organization. This is only returned when updating 
an organization. */
    billingAddress?: string | undefined;
    reposUrl?: string | undefined;
    eventsUrl?: string | undefined;
    hooksUrl?: string | undefined;
    issuesUrl?: string | undefined;
    membersUrl?: string | undefined;
    publicMembersUrl?: string | undefined;
    description?: string | undefined;
    isVerified?: boolean;
    hasOrganizationProjects?: boolean;
    hasRepositoryProjects?: boolean;
    updatedAt?: Date;

    constructor(data?: IOrganization) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.billingAddress = _data["billingAddress"];
            this.reposUrl = _data["reposUrl"];
            this.eventsUrl = _data["eventsUrl"];
            this.hooksUrl = _data["hooksUrl"];
            this.issuesUrl = _data["issuesUrl"];
            this.membersUrl = _data["membersUrl"];
            this.publicMembersUrl = _data["publicMembersUrl"];
            this.description = _data["description"];
            this.isVerified = _data["isVerified"];
            this.hasOrganizationProjects = _data["hasOrganizationProjects"];
            this.hasRepositoryProjects = _data["hasRepositoryProjects"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingAddress"] = this.billingAddress;
        data["reposUrl"] = this.reposUrl;
        data["eventsUrl"] = this.eventsUrl;
        data["hooksUrl"] = this.hooksUrl;
        data["issuesUrl"] = this.issuesUrl;
        data["membersUrl"] = this.membersUrl;
        data["publicMembersUrl"] = this.publicMembersUrl;
        data["description"] = this.description;
        data["isVerified"] = this.isVerified;
        data["hasOrganizationProjects"] = this.hasOrganizationProjects;
        data["hasRepositoryProjects"] = this.hasRepositoryProjects;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IOrganization extends IAccount {
    /** The billing address for an organization. This is only returned when updating 
an organization. */
    billingAddress?: string | undefined;
    reposUrl?: string | undefined;
    eventsUrl?: string | undefined;
    hooksUrl?: string | undefined;
    issuesUrl?: string | undefined;
    membersUrl?: string | undefined;
    publicMembersUrl?: string | undefined;
    description?: string | undefined;
    isVerified?: boolean;
    hasOrganizationProjects?: boolean;
    hasRepositoryProjects?: boolean;
    updatedAt?: Date;
}

export class RepoContributionResponse implements IRepoContributionResponse {
    locForFiles?: { [key: string]: AddedRemoved; } | undefined;

    constructor(data?: IRepoContributionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["locForFiles"]) {
                this.locForFiles = {} as any;
                for (let key in _data["locForFiles"]) {
                    if (_data["locForFiles"].hasOwnProperty(key))
                        (<any>this.locForFiles)![key] = _data["locForFiles"][key] ? AddedRemoved.fromJS(_data["locForFiles"][key]) : new AddedRemoved();
                }
            }
        }
    }

    static fromJS(data: any): RepoContributionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RepoContributionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.locForFiles) {
            data["locForFiles"] = {};
            for (let key in this.locForFiles) {
                if (this.locForFiles.hasOwnProperty(key))
                    (<any>data["locForFiles"])[key] = this.locForFiles[key] ? this.locForFiles[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }
}

export interface IRepoContributionResponse {
    locForFiles?: { [key: string]: AddedRemoved; } | undefined;
}

export class AddedRemoved implements IAddedRemoved {
    added?: number;
    removed?: number;

    constructor(data?: IAddedRemoved) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.added = _data["added"];
            this.removed = _data["removed"];
        }
    }

    static fromJS(data: any): AddedRemoved {
        data = typeof data === 'object' ? data : {};
        let result = new AddedRemoved();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["added"] = this.added;
        data["removed"] = this.removed;
        return data; 
    }
}

export interface IAddedRemoved {
    added?: number;
    removed?: number;
}

export class RepoSummaryResponse implements IRepoSummaryResponse {
    ownershipPercentage?: number;
    locContributed?: number;
    locRemoved?: number;
    averageCyclomaticComplexity?: number;
    totalIssues?: number;
    issuesRaised?: number;
    issuesSolved?: number;
    analysisIssues?: number;

    constructor(data?: IRepoSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ownershipPercentage = _data["ownershipPercentage"];
            this.locContributed = _data["locContributed"];
            this.locRemoved = _data["locRemoved"];
            this.averageCyclomaticComplexity = _data["averageCyclomaticComplexity"];
            this.totalIssues = _data["totalIssues"];
            this.issuesRaised = _data["issuesRaised"];
            this.issuesSolved = _data["issuesSolved"];
            this.analysisIssues = _data["analysisIssues"];
        }
    }

    static fromJS(data: any): RepoSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RepoSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownershipPercentage"] = this.ownershipPercentage;
        data["locContributed"] = this.locContributed;
        data["locRemoved"] = this.locRemoved;
        data["averageCyclomaticComplexity"] = this.averageCyclomaticComplexity;
        data["totalIssues"] = this.totalIssues;
        data["issuesRaised"] = this.issuesRaised;
        data["issuesSolved"] = this.issuesSolved;
        data["analysisIssues"] = this.analysisIssues;
        return data; 
    }
}

export interface IRepoSummaryResponse {
    ownershipPercentage?: number;
    locContributed?: number;
    locRemoved?: number;
    averageCyclomaticComplexity?: number;
    totalIssues?: number;
    issuesRaised?: number;
    issuesSolved?: number;
    analysisIssues?: number;
}

export class UserActivity implements IUserActivity {
    notifications?: Notification[] | undefined;
    events?: Activity[] | undefined;

    constructor(data?: IUserActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(Notification.fromJS(item));
            }
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(Activity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserActivity {
        data = typeof data === 'object' ? data : {};
        let result = new UserActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserActivity {
    notifications?: Notification[] | undefined;
    events?: Activity[] | undefined;
}

export class Notification implements INotification {
    id?: string | undefined;
    repository?: Repository | undefined;
    subject?: NotificationInfo | undefined;
    reason?: string | undefined;
    unread?: boolean;
    updatedAt?: string | undefined;
    lastReadAt?: string | undefined;
    url?: string | undefined;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
            this.subject = _data["subject"] ? NotificationInfo.fromJS(_data["subject"]) : <any>undefined;
            this.reason = _data["reason"];
            this.unread = _data["unread"];
            this.updatedAt = _data["updatedAt"];
            this.lastReadAt = _data["lastReadAt"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["reason"] = this.reason;
        data["unread"] = this.unread;
        data["updatedAt"] = this.updatedAt;
        data["lastReadAt"] = this.lastReadAt;
        data["url"] = this.url;
        return data; 
    }
}

export interface INotification {
    id?: string | undefined;
    repository?: Repository | undefined;
    subject?: NotificationInfo | undefined;
    reason?: string | undefined;
    unread?: boolean;
    updatedAt?: string | undefined;
    lastReadAt?: string | undefined;
    url?: string | undefined;
}

export class NotificationInfo implements INotificationInfo {
    title?: string | undefined;
    url?: string | undefined;
    latestCommentUrl?: string | undefined;
    type?: string | undefined;

    constructor(data?: INotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.url = _data["url"];
            this.latestCommentUrl = _data["latestCommentUrl"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): NotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["url"] = this.url;
        data["latestCommentUrl"] = this.latestCommentUrl;
        data["type"] = this.type;
        return data; 
    }
}

export interface INotificationInfo {
    title?: string | undefined;
    url?: string | undefined;
    latestCommentUrl?: string | undefined;
    type?: string | undefined;
}

/** An entry in the activity event stream */
export class Activity implements IActivity {
    /** The type of the activity. */
    type?: string | undefined;
    /** Whether the activity event is public or not. */
    public?: boolean;
    /** The repository associated with the activity event. */
    repo?: Repository | undefined;
    /** The user associated with the activity event. */
    actor?: User | undefined;
    /** The organization associated with the activity event. */
    org?: Organization | undefined;
    /** The date the activity event was created. */
    createdAt?: Date;
    /** The activity event Id. */
    id?: string | undefined;
    /** The payload associated with the activity event. */
    payload?: ActivityPayload | undefined;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.public = _data["public"];
            this.repo = _data["repo"] ? Repository.fromJS(_data["repo"]) : <any>undefined;
            this.actor = _data["actor"] ? User.fromJS(_data["actor"]) : <any>undefined;
            this.org = _data["org"] ? Organization.fromJS(_data["org"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.payload = _data["payload"] ? ActivityPayload.fromJS(_data["payload"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["public"] = this.public;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["org"] = this.org ? this.org.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        return data; 
    }
}

/** An entry in the activity event stream */
export interface IActivity {
    /** The type of the activity. */
    type?: string | undefined;
    /** Whether the activity event is public or not. */
    public?: boolean;
    /** The repository associated with the activity event. */
    repo?: Repository | undefined;
    /** The user associated with the activity event. */
    actor?: User | undefined;
    /** The organization associated with the activity event. */
    org?: Organization | undefined;
    /** The date the activity event was created. */
    createdAt?: Date;
    /** The activity event Id. */
    id?: string | undefined;
    /** The payload associated with the activity event. */
    payload?: ActivityPayload | undefined;
}

export class ActivityPayload implements IActivityPayload {
    repository?: Repository | undefined;
    sender?: User | undefined;
    installation?: InstallationId | undefined;

    constructor(data?: IActivityPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repository = _data["repository"] ? Repository.fromJS(_data["repository"]) : <any>undefined;
            this.sender = _data["sender"] ? User.fromJS(_data["sender"]) : <any>undefined;
            this.installation = _data["installation"] ? InstallationId.fromJS(_data["installation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["installation"] = this.installation ? this.installation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActivityPayload {
    repository?: Repository | undefined;
    sender?: User | undefined;
    installation?: InstallationId | undefined;
}

export class InstallationId implements IInstallationId {
    /** The Installation Id. */
    id?: number;

    constructor(data?: IInstallationId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InstallationId {
        data = typeof data === 'object' ? data : {};
        let result = new InstallationId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IInstallationId {
    /** The Installation Id. */
    id?: number;
}

export class UserLandingPageStatistics implements IUserLandingPageStatistics {
    events?: Activity[] | undefined;
    topRepoActivity?: { [key: string]: CommitActivity; } | undefined;
    languages?: { [key: string]: number; } | undefined;

    constructor(data?: IUserLandingPageStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(Activity.fromJS(item));
            }
            if (_data["topRepoActivity"]) {
                this.topRepoActivity = {} as any;
                for (let key in _data["topRepoActivity"]) {
                    if (_data["topRepoActivity"].hasOwnProperty(key))
                        (<any>this.topRepoActivity)![key] = _data["topRepoActivity"][key] ? CommitActivity.fromJS(_data["topRepoActivity"][key]) : new CommitActivity();
                }
            }
            if (_data["languages"]) {
                this.languages = {} as any;
                for (let key in _data["languages"]) {
                    if (_data["languages"].hasOwnProperty(key))
                        (<any>this.languages)![key] = _data["languages"][key];
                }
            }
        }
    }

    static fromJS(data: any): UserLandingPageStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new UserLandingPageStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        if (this.topRepoActivity) {
            data["topRepoActivity"] = {};
            for (let key in this.topRepoActivity) {
                if (this.topRepoActivity.hasOwnProperty(key))
                    (<any>data["topRepoActivity"])[key] = this.topRepoActivity[key] ? this.topRepoActivity[key].toJSON() : <any>undefined;
            }
        }
        if (this.languages) {
            data["languages"] = {};
            for (let key in this.languages) {
                if (this.languages.hasOwnProperty(key))
                    (<any>data["languages"])[key] = this.languages[key];
            }
        }
        return data; 
    }
}

export interface IUserLandingPageStatistics {
    events?: Activity[] | undefined;
    topRepoActivity?: { [key: string]: CommitActivity; } | undefined;
    languages?: { [key: string]: number; } | undefined;
}

export class ClientMetadata implements IClientMetadata {
    page?: string | undefined;
    referrer?: string | undefined;
    browserName?: string | undefined;
    browserEngine?: string | undefined;
    browserLanguage?: string | undefined;
    cookiesEnabled?: boolean;

    constructor(data?: IClientMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.referrer = _data["referrer"];
            this.browserName = _data["browserName"];
            this.browserEngine = _data["browserEngine"];
            this.browserLanguage = _data["browserLanguage"];
            this.cookiesEnabled = _data["cookiesEnabled"];
        }
    }

    static fromJS(data: any): ClientMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ClientMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["referrer"] = this.referrer;
        data["browserName"] = this.browserName;
        data["browserEngine"] = this.browserEngine;
        data["browserLanguage"] = this.browserLanguage;
        data["cookiesEnabled"] = this.cookiesEnabled;
        return data; 
    }
}

export interface IClientMetadata {
    page?: string | undefined;
    referrer?: string | undefined;
    browserName?: string | undefined;
    browserEngine?: string | undefined;
    browserLanguage?: string | undefined;
    cookiesEnabled?: boolean;
}

export enum SignalRNotificationType {
    RepoAnalysisProgressUpdate = 1,
    PullRequestAnalysisProgressUpdate = 2,
    RepoAnalysisDone = 3,
    PullRequestAnalysisDone = 4,
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}